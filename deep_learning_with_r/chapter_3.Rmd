---
title: '3장 : 신경망 입문'
output: html_document
date: "2025-11-24"
header-includes:
  - \newcommand{\bm}[1]{\boldsymbol{\mathbf{#1}}}
---
# 3장에서 다루는 내용

- 신경망의 핵심 구성 요소

- 케라스 소개

- 딥러닝 워크스테이션 설정

- 신경망을 사용해 기본적인 분류 및 회귀 문제 해결하기

## 3.1 신경망 해부학

신경망 훈련 구성 요소

- 망(network), 즉 모델(model)을 구성하는 계층(layers)

- 입력 데이터(input data)및 표적(targets)

- 학습에 사용된 피드백 신호를 정의하는 손실 함수(loss function)

- 학습이 어떻게 진행되는지를 결정하는 최적화기(optimizer)

망을 함께 연결하여 입력 데이터로부터 예측 값을 구하고, 손실 함수는 이러한 예측을 표적과 비교하여 손실 값을 산출한다. 망 예측이 예상했던 것과 얼마나 일치하는지를 측정하고, 최적화기는 손실 값을 통해 망의 가중치를 계산한다.


### 3.1.1 계층 : 딥러닝의 기본 요소

- 계층 : 하나 이상의 텐서를 입력으로 받아 하나 이상의 텐서를 출력하는 데이터 처리 모듈
  - 일부 계층은 상태가 비저장, 그 밖의 계층은 계층의 가중치들을 상태로 저장
  - 저장된 가중치를 확률적 경사 하강법등의 최적화기로 학습시키며, 이 가중치들에 망의 지식(knowledge)이 담긴다.
  
- 완전 연결 계층(fully connected layers, FC layers) 또는 조밀 계층(dense layers) : (표본, 특징) 모양으로 된 2D 텐서로 저장된 간단한 벡터 데이터에 적용

- 재귀 계층 (recurrent layers) : 3D 텐서 모양(표본, 시간대, 특징)에 저장된 시퀀스 데이터는 `layer_lstm` 등의 재귀 계층으로 처리된다.

- 합성곱 계층(convolutional layers) : 4D 텐서로 저장된 이미지 데이터는 2D 합성곱 계층 `layer_conv_2d`으로 처리된다.

계층은 딥러닝 전용 레고(LEGO) 블록이라고 생각할 수 있다. 이는 케라스와 같은 프레임워크에서 명시적으로 표현해둔 은유이다. 케라스의 딥러닝 모델 구축은 호환 가능한 계층을 오려내서 유용한 데이터 변환 통로를 형성하는 식으로 수행된다.

여기서 계층 호환성(layer compatibility)이라는 개념은 모든 계층이 특정 모양의 입력 텐서만 받아들이고, 특정 모양의 출력 텐서를 반환한다는 사실을 구체적으로 나타낸 개념이다.

케라스 사용시에는 모델에 추가하는 계층이 들어오는 계층의 모양과 일치하도록 동적으로 만들어지므로 호환성을 염려하지 않아도 된다. 예를 들어

```{r, eval=FALSE}
model = keras_model_sequential() %>% 
  layer_dense(units = 32, input_shape = c(784)) %>% 
  layer_dense(units = 32)
```

의 경우, 두번째 계층은 입력 모양 인수를 받지 못했으나, 입력 모양이 이전에 들어온 계층의 출력 모양(32)으로 유추된다.

### 3.1.2 모델 : 계층으로 이뤄진 망

딥러닝 모델이란, 방향성이 있고 순환하지 않는 그래프이다(DAG, Directed Acyclic Graph). 가장 쉬운 예로 단일 입력을 단일 출력으로 사상하도록 계층을 선형으로 쌓아올린 것을 생각할 수 있다.

그러나 이러한 이러한 예 외에 훨씬 다양한 네트워크 위상(network topologies)에 노출될 것이다. 다음과 같은 예들이 있다.

- 2분지 망(two-branch networks)
- 다중 헤드 망(multihead networks)
- 인셉션 블록(inception blocks)

네트워크 위상은 가설 공간을 정의하며, 네트워크 위상을 선택하게 되면 가능성의 공간(space of probabilities)을 일련의 특정 텐서 연산으로 제한하여 입력 데이터를 출력 데이터에 사상하게 된다. 이를 위해서는 텐서 연산에 관련된 가중치 소수점에 대한 좋은 값 집합을 찾아야 한다(무슨 소리인지 명확히는 이해못함).

적절한 망 아키텍처를 선택하는 일에는 과학이 아닌 예술이 필요하다(내가 어렴풋이 느끼던 딥러닝은 뭔가 과학이 아니라 아트같다는 느낌을 프랑소와 숄레 도 느끼고 있었다). 이러한 예술감각에는 몇 가지 모범 사례와 원칙이 있겠지만, 단지 연습만으로도 적절한 신경망 설계자가 될 수 있다.

### 3.1.3 손실 함수 및 최적화기 : 학습 과정을 구성하는 데 필요한 핵심 요소

망 아키텍처를 정의하고 나서도 두 가지를 더 선택해야 한다.

- 손실 함수(목적 함수) : 훈련하면서 최소화하는 양. 손실 함수는 당면 과제를 성공적으로 수행할 수 있는 메트릭이어야 한다.

- 최적화기 : 손실 함수에 따라 망을 갱신하는 방법을 결정한다. 최적화기는 확률적 경사 하강(SGD)의 특정 변형을 구현한다.

출력이 여러 개인 신경망에는 손실 함수가 여러 개 있을 수 있다(출력마다 하나씩). 그러나 경사 하강 과정은 단일 스칼라 손실 값을 기반으로 해야 한다. 따라서 다중 망의 경우, 모든 손실이 (평균화를 통해) 단일(single) 스칼라 수량으로 결합된다.

올바른 문제에 맞게 적절한 목적 함수를 선택하는 일은 매우 중요하다. 즉, 망은 손실을 최소화하기 위해 가능한 한 모든 지름길을 취한다. 따라서 목적이 현재 진행 중인 작업의 성공과 완전히 관련되지 않으면 망은 여러분이 원치 않는 일을 하게 된다(책에 훌륭한 예시가 있다). 따라서 객관적으로 봐서도 현명하다고 할 만한 손실 함수를 선택해야 하고 그렇게 하지 않는다면 의도하지 않은 부작용(side effects)에 직면할 수 있다.

다행히도 분류, 회귀 및 시퀀스 예측과 같은 일반적인 문제에 관해서 정확한 손실을 선택하기 위해 따라야만 하는 지침이 있다. 예를 들어, 2개 클래스로 분류하는 문제에 대한 이항 교차 엔트로피(BCE, binary cross entropy), 다중 클래스 분류 문제에는 범주적 교차 엔트로피(CCE, categorical cros entropy), 회귀 문제에는 평균제곱오차(MSE, mean squared error), 시퀀스 학습 문제에는 연결자 시간 분류(CTC, connectionist temporal classification) 등을 쓰면 될 것이다. 이러한 일반적인 문제가 아닌 새로운 연구 주제에 진심으로 골몰하는 경우에만 자신만의 목적에 맞는 손실 함수를 개발하면 될 것이다.

## 3.2 케라스 소개

케라스의 주요 기능

- 동일한 코드를 CPU에서나, GPU에서나 원활하게 실행할 수 있다.

- 사용자 친화 API를 사용하므로 딥러닝 모델을 신속하게 시범 제작해 볼 수 있다.

- 합성곱 망(컴퓨터 비전용), 재귀 망(시퀀스 처리용)및 이 두가지의 조합을 기본적으로 지원한다.

- 다중 입력 또는 다중 출력 모델, 계층 공유, 모델 공유 등 임의의 망 아키텍처를 지원한다. 

### 3.2.1 케라스, 텐서플로, 테아노 및 CNTK

케라스는 딥러닝 모델을 개발할 수 있는 고급 구성 요소를 제공하는 모델 수준 라이브러리이다. 텐서 연산 및 미분과 같은 저수준 연산은 처리하지 않는다. 그 대신, 케라스의 백엔드 엔진 역할을 하는 전문화되고 잘 최적화된 텐서 라이브러리에 의존한다.

케라스는 단일 텐서 라이브러리를 선택하고 그 라이브러리에 케라스 구현을 묶는 대신, 모듈 방식으로 문제를 처리한다. 따라서 여러 다른 백엔드 엔진을 케라스에 원활하게 연결할 수 있다(이후의 내용은 deprecated된 내용으로 생략한다).

테아노는 몬트리올 대학교 소속 MILA 연구소, 텐서플로는 구글, CNTK는 마이크로소프트에서 개발했다. 케라스로 작성한 모든 코드는 해당 코드에서 아무것도 변경하지 않은 채로 이러한 백엔드 중 하나를 선택하여 실행할 수 있다. 예를 들어, 이러한 백엔드 중 하나가 특정 작업에 더 빠르다는 게 증명되면 개발 중이더라도 두 가지 백엔드들 사이에서 원활하게 전환할 수 있다.

### 3.2.2 케라스 설치

케라스를 시작하려면 케라스 R 패키지, 핵심 케라스 라이브러리 및 백엔드용 텐서 엔진(예 : 텐서플로)을 설치해야 한다.

GPU를 활용하여 딥러닝 모델을 훈련하려면 텐서플로 백엔드 엔진의 GPU 기반 버전을 설치하는 것이 좋다.

```{r, eval=FALSE}
install_keras(tensorflow = "gpu")
```

그러나 이에 앞서 엔비디아 GPU 및 필수 소프트웨어(CUDA 및 cuDNN)이 있는 경우에만 위의 코드를 실행하는 것이 맞다.

### 3.2.3 케라스 이용 개발 : 훑어보기
