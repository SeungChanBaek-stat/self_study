x = c(1, 2, 3)
Ey = t(x) %*% mult_res$beta_hat
t_0 = (Ey - 4) / sqrt((t(x) %*% solve(mult_res$XtX) %*% x ) * MSE)
t_alpha = qt(0.025, n-p-1, lower.tail = FALSE)
print(glue("t_0 = {t_0}, t_alpha = {t_alpha}"))
x = c(0, 0, 1)
beta2hat = t(x) %*% mult_res$beta_hat
t_0 = (beta2hat - 0) / sqrt((t(x) %*% solve(mult_res$XtX) %*% x ) * MSE)
t_alpha = qt(0.05, n-p-1, lower.tail = FALSE)
print(glue("t_0 = {t_0}, t_alpha = {t_alpha}"))
c1 = c(0, 1, -2) ; C = rbind(c1) ; m = 0
x_r1 = x1 + x2/2
X_r = matrix(x_r1, nrow = length(x_r1)) ; y_r = y
mult_test_res1 = mult_test(C, m, X, X_r, y, y_r, alpha = 0.05, method = "one", coef = TRUE)
mult_test_res2 = mult_test(C, m, X, X_r, y, y_r, alpha = 0.05, method = "two", coef = TRUE)
SSE_F = mult_test_res2$SSE_F ; SSE_F
SSE_R = mult_test_res2$SSE_R ; SSE_R
Q = mult_test_res1$Q ; Q
x1 = c(10, 24, 25, 28, 15, 18, 22, 22, 12, 15) ; x2 = c(27, 26, 28, 26, 30, 24, 27, 25, 27, 25)
x3 = c(64, 72, 80, 88, 81, 45, 46, 69, 54, 39)
X = cbind(x1, x2, x3) ; y = c(2.8, 3.9, 3.9, 4.4, 3.1, 3.1, 3.5, 3.6, 3.0, 3.3)
n = dim(X)[1] ; p = dim(X)[2]
mult_res = mult_reg(X, y, alpha = 0.05, coeff = TRUE)
MSE = mult_res$MSE
a = c(0,0,0,1) ; beta3hat = t(a) %*% mult_res$beta_hat
var_hat_beta3hat = t(a) %*% solve(mult_res$XtX) %*% a * MSE
t_alpha = qt(0.025, n-p-1, lower.tail = FALSE)
CI_lower = beta3hat - t_alpha * sqrt(var_hat_beta3hat)
CI_upper = beta3hat + t_alpha * sqrt(var_hat_beta3hat)
print(glue("beta3hat CI = ({CI_lower}, {CI_upper})"))
a = c(0,1,0,0) ; beta1hat = t(a) %*% mult_res$beta_hat
var_hat_beta1hat = t(a) %*% solve(mult_res$XtX) %*% a * MSE
t_alpha = qt(0.005, n-p-1, lower.tail = FALSE)
CI_lower = beta1hat - t_alpha * sqrt(var_hat_beta1hat)
CI_upper = beta1hat + t_alpha * sqrt(var_hat_beta1hat)
print(glue("beta1hat CI = ({CI_lower}, {CI_upper})"))
x = c(1,20,27,60) ; yhat = t(x) %*% mult_res$beta_hat
var_hat_yhat = t(x) %*% solve(mult_res$XtX) %*% x * MSE
t_alpha = qt(0.025, n-p-1, lower.tail = FALSE)
CI_lower = yhat - t_alpha * sqrt(var_hat_yhat)
CI_upper = yhat + t_alpha * sqrt(var_hat_yhat)
print(glue("yhat CI = ({CI_lower}, {CI_upper})"))
a = c(0,1,0,0)
beta1hat = t(a) %*% mult_res$beta_hat
t_0 = (beta1hat - 0) / sqrt( t(a) %*% solve(mult_res$XtX) %*% a * MSE)
t_alpha = qt(0.05, n-p-1, lower.tail = FALSE)
print(glue("t_0 = {t_0}, t_alpha = {t_alpha}"))
c1 = c(0,1,-1,0) ; c2 = c(0,0,1,-1)
C = rbind(c1,c2) ; m = 0
mult_test_res1 = mult_test(C, m, X, X_r, y, y_r, alpha = 0.05, method = "one", coef = TRUE)
Q = mult_test_res1$Q ; Q
c1 = c(0,1,-1,0)
C = rbind(c1) ; m = 3
mult_test_res1 = mult_test(C, m, X, X_r, y, y_r, alpha = 0.05, method = "one", coef = TRUE)
Q = mult_test_res1$Q ; Q
x = c(1, 20, 27, 60) ; yhat = t(x) %*% mult_res$beta_hat
var_hat_yhat = t(x) %*% solve(mult_res$XtX) %*% x * MSE
t_0  = (yhat - 3.5) / sqrt(var_hat_yhat) ; t_0
t_alpha = qt(0.025, n-p-1, lower.tail = FALSE) ; t_alpha
beta_tilde_est = function(C, m, X, y){
one = c(rep(1, n)) ; X = cbind(one, X)
XtX_inv = solve( t(X) %*% X )
beta_hat = XtX_inv %*% t(X) %*% y
print(glue("{dim(XtX_inv)}, {dim(t(C))}"))
beta_tilde = beta_hat - XtX_inv %*% t(C) %*% solve(C %*% XtX_inv %*% t(C)) %*% (C %*% beta_hat - m)
return(beta_tilde)
}
c1 = c(0, 1, -1, 0) ; c2 = c(0, 0, 1, -1) ; C = rbind(c1, c2)
m1 = 0 ; m2 = 0 ; m = rbind(m1, m2)
beta_tilde = beta_tilde_est(C, m, X, y) ; beta_tilde
c1 = c(0, 1, -1, 0) ; C = rbind(c1)
m1 = 3 ; m = rbind(m1)
beta_tilde = beta_tilde_est(C, m, X, y) ; beta_tilde
x1 = c(10, 24, 25, 28, 15, 18, 22, 22, 12, 15)
x2 = c(27, 26, 28, 26, 30, 24, 27, 25, 27, 25) ; x3 = c(64, 72, 80, 88, 81, 45, 46, 69, 54, 39)
X = cbind(x1, x2, x3) ; y = c(2.8, 3.9, 3.9, 4.4, 3.1, 3.1, 3.5, 3.6, 3.0, 3.3)
mult_res = mult_reg(X, y, alpha = 0.05, coeff = FALSE)
beta_hat = mult_res$beta_hat ; beta_hat
MSE = mult_res$MSE ; n = dim(X)[1] ; p = dim(X)[2]
a = c(0, 1, 0) ; beta2hat = t(a) %*% beta_hat
var_hat_beta2hat = t(a) %*% solve(mult_res$XtX) %*% a * MSE
t_alpha = qt(0.025, n-p, lower.tail = FALSE)
CI_lower = beta2hat - t_alpha * sqrt(var_hat_beta2hat)
CI_upper = beta2hat + t_alpha * sqrt(var_hat_beta2hat)
print(glue("beta2hat CI = ({CI_lower},{CI_upper})"))
c1 = c(0,1,0) ; C = rbind(c1) ; m1 = 0 ; m = rbind(m1)
mult_test_res = mult_test(C, m, X, X_r, y, y_r, alpha = 0.05, method = "one", coef = FALSE)
Q = mult_test_res$Q ; Q
c1 = c(1, -1, 0) ; c2 = c(0, 1, -1) ; C = rbind(c1, c2) ; m1 = 0 ; m2 = 0 ; m = rbind(m1, m2)
mult_test_res = mult_test(C, m, X, X_r, y, y_r, alpha = 0.05, method = "one", coef = FALSE)
Q = mult_test_res$Q ; Q
y1 = c(2.0, 5.7, 4.5, 5.3) ; y2 = c(2.3, 4.8, 4.2, 5.5)
x1 = c(-1, 1, -1, 1) ; x2 = c(-1, -1, 1, 1)
ni = 2 ; k = length(x1)
X0 = c(rep(1, ni * k)) ; X1 = c(rep(x1, 2)) ; X2 = c(rep(x2, 2)) ;
X = cbind(X0, X1, X2) ; Y = c(y1, y2)
In = diag(1, ni * k) ; H = X %*% solve( t(X) %*% X) %*% t(X)
yhat = H %*% Y ; yhat
ybar_i = c(rep(0, k))
for (i in 1:k){
ybar_i[i] = (y1[i] + y2[i])/2
}
SSPE = sum(y1^2 + y2^2) - sum(ni * ybar_i^2) ; SSPE
SSLF = sum(ni * (ybar_i - yhat[1:k,])^2) ; SSLF
SSE = t(Y) %*% (In - H) %*% Y ; SSE
F_L = (SSLF / 1) / (SSPE / 4) ; F_L
F_alpha = qf(0.05, 1, 4, lower.tail = FALSE) ; F_alpha
e = (In - H) %*% Y ; yhat = H %*% Y ; X1 = X1 ; X2 = X2
# par(mfrow=c(1, 3))
plot(x = yhat, y = e, xlab = expression(hat(y)[i]), ylab = expression(e[i]),
main = expression(paste("(a)", hat(y)[i], "에 대하여")))
plot(x = X1, y = e, xlab = expression(x[i1]), ylab = expression(e[i]),
main = expression(paste("(b)", x[i1], "에 대하여")))
plot(x = X2, y = e, xlab = expression(x[i2]), ylab = expression(e[i]),
main = expression(paste("(c)", x[i2], "에 대하여")))
e = (In - H) %*% Y ; yhat = H %*% Y ; X1 = X1 ; X2 = X2
## (a)
sum(e)
## (b)
t(e) %*% yhat
## (c)
t(X1) %*% e
## (d)
t(X2) %*% e
x1 = c(1, 2, 1, 3, 3, 3) ; x2 = c(1, 1, 2, 1, 2, 3)
y = c(1, 5, 0, 4, 4, -1) ; X = cbind(x1, x2)
n = length(x1) ; x0 = c(rep(1, n)) ; X = cbind(x0, X) ; In = diag(1, n) ; p = 2
H = X %*% solve(t(X) %*% X) %*% t(X)
e = (In - H) %*% y
SSE = t(y) %*% e ; MSE = as.numeric(SSE/ (n-p-1))
var_e = (In - H) ; var_e
varhat_e = MSE * (In - H) ; varhat_e
rho12 = var_e[1,2] / sqrt(var_e[1,1] * var_e[2,2]) ; rho12
x1 = c(1,2,3,1,2,3) ; x2 = c(-1,-1,-1,1,1,1) ; x3 = c(-1,0,1,1,0,-1)
y = c(7,8,10,15,18,26) ; X = cbind(x1,x2,x3) ; n = dim(X)[1], p = dim(X)[2] ; alpha = 0.05
x1 = c(1,2,3,1,2,3) ; x2 = c(-1,-1,-1,1,1,1) ; x3 = c(-1,0,1,1,0,-1)
y = c(7,8,10,15,18,26) ; X = cbind(x1,x2,x3) ; n = dim(X)[1] ; p = dim(X)[2] ; alpha = 0.05
one = c(rep(1,n)) ; X = cbind(one, X)
XtX_inv = solve(t(X) %*% X) ; Xty = t(X) %*% y ; yty = t(y) %*% y
beta_hat = XtX_inv %*% Xty
SSR = t(beta_hat) %*% Xty ; SSE = yty - t(beta_hat) %*% Xty ; SST = yty
df_SSR = p + 1 ; df_SSE = n - p - 1 ; df_total = n
MSR = SSR / df_SSR ; MSE = SSE / df_SSE
F_0 = MSR / MSE ; F_alpha = qf(alpha, df_SSR, df_SSE, lower.tail = FALSE)
anova_table = data.frame(
요인 = c("회귀", "잔차", "계"),
제곱합 = c(SSR, SSE, SST),
자유도 = c(df_SSR, df_SSE, df_total),
평균제곱합 = c(MSR, MSE, NA)
F_0 = c(F_0, NA, NA)
one = c(rep(1,n)) ; X = cbind(one, X)
XtX_inv = solve(t(X) %*% X) ; Xty = t(X) %*% y ; yty = t(y) %*% y
x1 = c(1,2,3,1,2,3) ; x2 = c(-1,-1,-1,1,1,1) ; x3 = c(-1,0,1,1,0,-1)
y = c(7,8,10,15,18,26) ; X = cbind(x1,x2,x3) ; n = dim(X)[1] ; p = dim(X)[2] ; alpha = 0.05
n ; p
one = c(rep(1,n)) ; X = cbind(one, X)
X
XtX_inv = solve(t(X) %*% X) ; Xty = t(X) %*% y ; yty = t(y) %*% y
x1 = c(1,2,3,1,2,3) ; x2 = c(-1,-1,-1,1,1,1) ; x3 = c(-1,0,1,1,0,-1)
y = c(7,8,10,15,18,26) ; X = cbind(x1,x2,x3) ; n = dim(X)[1] ; p = dim(X)[2] ; alpha = 0.05
one = c(rep(1,n)) ; X = cbind(one, X)
XtX_inv = solve(t(X) %*% X) ; Xty = t(X) %*% y ; yty = t(y) %*% y
beta_hat = XtX_inv %*% Xty
SSR = t(beta_hat) %*% Xty ; SSE = yty - t(beta_hat) %*% Xty ; SST = yty
df_SSR = p + 1 ; df_SSE = n - p - 1 ; df_total = n
MSR = SSR / df_SSR ; MSE = SSE / df_SSE
F_0 = MSR / MSE ; F_alpha = qf(alpha, df_SSR, df_SSE, lower.tail = FALSE)
anova_table = data.frame(
요인 = c("회귀", "잔차", "계"),
제곱합 = c(SSR, SSE, SST),
자유도 = c(df_SSR, df_SSE, df_total),
평균제곱합 = c(MSR, MSE, NA),
F_0 = c(F_0, NA, NA),
F_alpha = c(F_alpha, NA, NA)
)
print(anova_table)
beta_hat
one = c(rep(1,n)) ; X = cbind(one, X)
XtX_inv = solve(t(X) %*% X) ; Xty = t(X) %*% y ; yty = t(y) %*% y
x1 = c(1,2,3,1,2,3) ; x2 = c(-1,-1,-1,1,1,1) ; x3 = c(-1,0,1,1,0,-1)
y = c(7,8,10,15,18,26) ; X = cbind(x1,x2,x3) ; n = dim(X)[1] ; p = dim(X)[2] ; alpha = 0.05
one = c(rep(1,n)) ; X = cbind(one, X)
XtX_inv = solve(t(X) %*% X) ; Xty = t(X) %*% y ; yty = t(y) %*% y
beta_hat = XtX_inv %*% Xty
SSR = t(beta_hat) %*% Xty ; SSE = yty - t(beta_hat) %*% Xty ; SST = yty
df_SSR = p + 1 ; df_SSE = n - p - 1 ; df_total = n
MSR = SSR / df_SSR ; MSE = SSE / df_SSE
F_0 = MSR / MSE ; F_alpha = qf(alpha, df_SSR, df_SSE, lower.tail = FALSE)
anova_table = data.frame(
요인 = c("회귀", "잔차", "계"),
제곱합 = c(SSR, SSE, SST),
자유도 = c(df_SSR, df_SSE, df_total),
평균제곱합 = c(MSR, MSE, NA),
F_0 = c(F_0, NA, NA),
F_alpha = c(F_alpha, NA, NA)
)
beta_hat
print(anova_table)
beta_hat = XtX_inv %*% Xty ; X_R = X[,c(1, 3, 4)] ; X_R ; X
beta_hat = XtX_inv %*% Xty ; X_R = X[,-c(2)] ; X_R ; X
beta_hat = XtX_inv %*% Xty ; X_R = X[,-c(2)] # X_R = X[,-c(2)] 와 X_R = X[,c(1, 3, 4)] 는 동일하다.
beta_hat_R = solve(t(X_R) %*% X_R) %*% t(X_R) %*% y
SS_F = t(beta_hat) %*% Xty
SS_R = t(beta_hat_R) %*% t(X_R) %*% y
SS_F - SS_R
beta_hat = XtX_inv %*% Xty ; X_R = X[,-c(2)] # X_R = X[,-c(2)] 와 X_R = X[,c(1, 3, 4)] 는 동일하다.
beta_hat_R = solve(t(X_R) %*% X_R) %*% t(X_R) %*% y
SS_F = t(beta_hat) %*% Xty
SS_R = t(beta_hat_R) %*% t(X_R) %*% y
SS_F - SS_R
F_0 = ((SS_F - SS_R)/(p - 2)) / (MSE) ; F_0
F_alpha = qf(alpha,p-2, n-p-1, lower.tail = FALSE) ; F_alpha
index = c(1,2)
X_1 = X[,index] ; X_2 = X[, -index] ; X_1 ; X_2
library(glue)
index = c(1,2)
X_1 = X[,index] ; X_2 = X[, -index] ; X_1 ; X_2
beta1_hat = solve(t(X_1) %*% X_1) %*% t(X_1) %*% y
beta2_hat = solve(t(X_2) %*% X_2) %*% t(X_2) %*% y
beta_hat = solve(t(X) %*% X) %*% t(X) %*% y
SS_beta1_hat = t(beta1_hat) %*% t(X_1) %*% y
SS_beta2_hat = t(beta2_hat) %*% t(X_2) %*% y
SS_beta_hat = t(beta_hat) %*% t(X) %*% y
print(glue("SS_beta1_hat = {SS_beta1_hat}, SS_beta2_hat = {SS_beta2_hat}, SS_beta_hat = {SS_beta_hat}"))
library(glue)
index = c(1,2)
X_1 = X[,index] ; X_2 = X[, -index]
beta1_hat = solve(t(X_1) %*% X_1) %*% t(X_1) %*% y
beta2_hat = solve(t(X_2) %*% X_2) %*% t(X_2) %*% y
beta_hat = solve(t(X) %*% X) %*% t(X) %*% y
SS_beta1_hat = t(beta1_hat) %*% t(X_1) %*% y
SS_beta2_hat = t(beta2_hat) %*% t(X_2) %*% y
SS_beta_hat = t(beta_hat) %*% t(X) %*% y
print(glue("SS_beta1_hat = {SS_beta1_hat}, SS_beta2_hat = {SS_beta2_hat}, SS_beta_hat = {SS_beta_hat}"))
x = c(30, 20, 60, 80, 40, 50, 60, 30, 70, 60)
y = c(73, 50, 128, 170, 97, 108, 135, 69, 148, 132)
n = length(x) ; one = c(rep(1,n)) ; X = cbind(one, x) ; p = 1
beta_hat = solve(t(X) %*% X) %*% t(X) %*% y ; beta_hat
beta_hat = solve(t(X) %*% X) %*% t(X) %*% y ; beta_hat
SSE = t(y) %*% y - t(beta_hat) %*% t(X) %*% y ; SSE
MSE = SSE/(n-p-1) ; MSE
# denum = (beta_hat)
library(ellipsis)
install.packages("ellipsis")
# install.packages("ellipsis")
library(ellipsis)
?ellipsis
x = c(30, 20, 60, 80, 40, 50, 60, 30, 70, 60)
y = c(73, 50, 128, 170, 97, 108, 135, 69, 148, 132)
n = length(x) ; one = c(rep(1,n)) ; X = cbind(one, x) ; p = 1
beta_hat = solve(t(X) %*% X) %*% t(X) %*% y ; beta_hat
SSE = t(y) %*% y - t(beta_hat) %*% t(X) %*% y ; SSE
MSE = SSE/(n-p-1) ; MSE
XtX = t(X) %*% X
F_alpha = qf(0.05, p+1, n-p-1, lower.tail = FALSE)
# install.packages("ellipsis")
library(ellipsis)
?ellipsis
joint_conf = ellipsis()
XtX = t(X) %*% X ; XtX
F_alpha = qf(0.05, p+1, n-p-1, lower.tail = FALSE) ; F_alpha
D = det(XtX) ; D
XtX_inv = solve(XtX) ; XtX_inv
var_hat_beta0_hat = XtX_inv[1,1] * MSE ; var_hat_beta0_hat
cov_hat_beta0beta1_hat = XtX_inv[1,2] * MSE ; cov_hat_beta0beta1_hat
var_hat_beta1_hat = XtX_inv[2,2] * MSE ; var_hat_beta1_hat
beta_hat = solve(t(X) %*% X) %*% t(X) %*% y ; beta_hat
SSE = t(y) %*% y - t(beta_hat) %*% t(X) %*% y ; SSE
MSE = SSE/(n-p-1) ; MSE
XtX = t(X) %*% X ; XtX
F_alpha = qf(0.05, p+1, n-p-1, lower.tail = FALSE) ; F_alpha
D = det(XtX) ; D
XtX_inv = solve(XtX) ; XtX_inv
var_hat_beta0_hat = XtX_inv[1,1] * MSE ; var_hat_beta0_hat
cov_hat_beta0beta1_hat = XtX_inv[1,2] * MSE ; cov_hat_beta0beta1_hat
var_hat_beta1_hat = XtX_inv[2,2] * MSE ; var_hat_beta1_hat
# 타원에 해당하는 상수
c_val <- (p + 1) * MSE * F_alpha
# (XtX)^{-1}의 제곱근을 구하기 위해 고유분해 사용
A <- solve(XtX)
eig_A <- eigen(A)
A_sqrt <- eig_A$vectors %*% diag(sqrt(eig_A$values)) %*% t(eig_A$vectors)
# 0~2pi 범위의 각도 생성
theta <- seq(0, 2 * pi, length.out = 100)
# 각 theta에 대해 타원 위의 점 계산
ellipse_coords <- t(sapply(theta, function(t) {
beta_hat + sqrt(c_val) * A_sqrt %*% c(cos(t), sin(t))
}))
beta_hat = solve(t(X) %*% X) %*% t(X) %*% y ; beta_hat
SSE = t(y) %*% y - t(beta_hat) %*% t(X) %*% y ; SSE
MSE = SSE/(n-p-1) ; MSE
XtX = t(X) %*% X ; XtX
F_alpha = qf(0.05, p+1, n-p-1, lower.tail = FALSE) ; F_alpha
D = det(XtX) ; D
XtX_inv = solve(XtX) ; XtX_inv
var_hat_beta0_hat = XtX_inv[1,1] * MSE ; var_hat_beta0_hat
cov_hat_beta0beta1_hat = XtX_inv[1,2] * MSE ; cov_hat_beta0beta1_hat
var_hat_beta1_hat = XtX_inv[2,2] * MSE ; var_hat_beta1_hat
# 타원에 해당하는 상수
c_val <- (p + 1) * MSE * F_alpha
# (XtX)^{-1}의 제곱근을 구하기 위해 고유분해 사용
A <- solve(XtX)
eig_A <- eigen(A)
A_sqrt <- eig_A$vectors %*% diag(sqrt(eig_A$values)) %*% t(eig_A$vectors)
# 0~2pi 범위의 각도 생성
theta <- seq(0, 2 * pi, length.out = 100)
# 각 theta에 대해 타원 위의 점 계산
ellipse_coords <- t(sapply(theta, function(t) {
dim(beta_hat) ; dim(c_val) ; dim(A_sqrt)
beta_hat + sqrt(c_val) * A_sqrt %*% c(cos(t), sin(t))
}))
beta_hat = solve(t(X) %*% X) %*% t(X) %*% y ; beta_hat
SSE = t(y) %*% y - t(beta_hat) %*% t(X) %*% y ; SSE
MSE = SSE/(n-p-1) ; MSE
XtX = t(X) %*% X ; XtX
F_alpha = qf(0.05, p+1, n-p-1, lower.tail = FALSE) ; F_alpha
D = det(XtX) ; D
XtX_inv = solve(XtX) ; XtX_inv
var_hat_beta0_hat = XtX_inv[1,1] * MSE ; var_hat_beta0_hat
cov_hat_beta0beta1_hat = XtX_inv[1,2] * MSE ; cov_hat_beta0beta1_hat
var_hat_beta1_hat = XtX_inv[2,2] * MSE ; var_hat_beta1_hat
# 타원에 해당하는 상수
c_val <- (p + 1) * MSE * F_alpha
# (XtX)^{-1}의 제곱근을 구하기 위해 고유분해 사용
A <- solve(XtX)
eig_A <- eigen(A)
A_sqrt <- eig_A$vectors %*% diag(sqrt(eig_A$values)) %*% t(eig_A$vectors)
# 0~2pi 범위의 각도 생성
theta <- seq(0, 2 * pi, length.out = 100)
# 각 theta에 대해 타원 위의 점 계산
ellipse_coords <- t(sapply(theta, function(t) {
cat(dim(beta_hat) ; dim(c_val) ; dim(A_sqrt))
beta_hat = solve(t(X) %*% X) %*% t(X) %*% y ; beta_hat
SSE = t(y) %*% y - t(beta_hat) %*% t(X) %*% y ; SSE
MSE = SSE/(n-p-1) ; MSE
XtX = t(X) %*% X ; XtX
F_alpha = qf(0.05, p+1, n-p-1, lower.tail = FALSE) ; F_alpha
D = det(XtX) ; D
XtX_inv = solve(XtX) ; XtX_inv
var_hat_beta0_hat = XtX_inv[1,1] * MSE ; var_hat_beta0_hat
cov_hat_beta0beta1_hat = XtX_inv[1,2] * MSE ; cov_hat_beta0beta1_hat
var_hat_beta1_hat = XtX_inv[2,2] * MSE ; var_hat_beta1_hat
# 타원에 해당하는 상수
c_val <- (p + 1) * MSE * F_alpha
# (XtX)^{-1}의 제곱근을 구하기 위해 고유분해 사용
A <- solve(XtX)
eig_A <- eigen(A)
A_sqrt <- eig_A$vectors %*% diag(sqrt(eig_A$values)) %*% t(eig_A$vectors)
# 0~2pi 범위의 각도 생성
theta <- seq(0, 2 * pi, length.out = 100)
# 각 theta에 대해 타원 위의 점 계산
ellipse_coords <- t(sapply(theta, function(t) {
cat(dim(beta_hat) , dim(c_val) , dim(A_sqrt))
beta_hat + sqrt(c_val) * A_sqrt %*% c(cos(t), sin(t))
}))
beta_hat = solve(t(X) %*% X) %*% t(X) %*% y ; beta_hat
SSE = t(y) %*% y - t(beta_hat) %*% t(X) %*% y ; SSE
MSE = SSE/(n-p-1) ; MSE
XtX = t(X) %*% X ; XtX
F_alpha = qf(0.05, p+1, n-p-1, lower.tail = FALSE) ; F_alpha
D = det(XtX) ; D
XtX_inv = solve(XtX) ; XtX_inv
var_hat_beta0_hat = XtX_inv[1,1] * MSE ; var_hat_beta0_hat
cov_hat_beta0beta1_hat = XtX_inv[1,2] * MSE ; cov_hat_beta0beta1_hat
var_hat_beta1_hat = XtX_inv[2,2] * MSE ; var_hat_beta1_hat
# 타원에 해당하는 상수
c_val <- (p + 1) * MSE * F_alpha
# (XtX)^{-1}의 제곱근을 구하기 위해 고유분해 사용
A <- solve(XtX)
eig_A <- eigen(A)
A_sqrt <- eig_A$vectors %*% diag(sqrt(eig_A$values)) %*% t(eig_A$vectors)
# 0~2pi 범위의 각도 생성
theta <- seq(0, 2 * pi, length.out = 100)
# 각 theta에 대해 타원 위의 점 계산
ellipse_coords <- t(sapply(theta, function(t) {
cat("beta_hat", dim(beta_hat) ,"c_val",  dim(c_val) ,"A_sqrt", dim(A_sqrt))
beta_hat + sqrt(c_val) * A_sqrt %*% c(cos(t), sin(t))
}))
beta_hat = solve(t(X) %*% X) %*% t(X) %*% y ; beta_hat
SSE = t(y) %*% y - t(beta_hat) %*% t(X) %*% y ; SSE
MSE = SSE/(n-p-1) ; MSE
XtX = t(X) %*% X ; XtX
F_alpha = qf(0.05, p+1, n-p-1, lower.tail = FALSE) ; F_alpha
D = det(XtX) ; D
XtX_inv = solve(XtX) ; XtX_inv
var_hat_beta0_hat = XtX_inv[1,1] * MSE ; var_hat_beta0_hat
cov_hat_beta0beta1_hat = XtX_inv[1,2] * MSE ; cov_hat_beta0beta1_hat
var_hat_beta1_hat = XtX_inv[2,2] * MSE ; var_hat_beta1_hat
# 타원에 해당하는 상수
c_val <- (p + 1) * MSE * F_alpha
# (XtX)^{-1}의 제곱근을 구하기 위해 고유분해 사용
A <- solve(XtX)
eig_A <- eigen(A)
A_sqrt <- eig_A$vectors %*% diag(sqrt(eig_A$values)) %*% t(eig_A$vectors)
# 0~2pi 범위의 각도 생성
theta <- seq(0, 2 * pi, length.out = 100)
# 각 theta에 대해 타원 위의 점 계산
ellipse_coords <- t(sapply(theta, function(t) {
# cat("beta_hat", dim(beta_hat) ,"c_val",  dim(c_val) ,"A_sqrt", dim(A_sqrt))
beta_hat + as.numeric(sqrt(c_val)) * A_sqrt %*% c(cos(t), sin(t))
}))
# 타원과 중심(beta_hat) 그리기
plot(ellipse_coords, type = "l",
xlab = expression(beta[0]), ylab = expression(beta[1]),
main = "신뢰영역 (타원) for beta")
points(beta_hat[1], beta_hat[2], col = "red", pch = 19)
data(Hitters)
library(MASS)
data(Hitters)
library(ISLR)
data(Hitters)
library(ISLR)
data(Hitters)
Hitters = Hitters %>% na.omit() %>% select(AtBat, Hits, HmRun, Salary)
install.packages("dplyr")
library(ISLR)
# install.packages("dplyr")
library(dplyr)
data(Hitters)
Hitters = Hitters %>% na.omit() %>% select(AtBat, Hits, HmRun, Salary)
fit <- lm(Salary ~ AtBat + Hits + HmRun, data = Hitters)
anova(fit)
fit2 <- lm(Salary ~ Hits + HmRun + AtBat, data = Hitters) # 설명변수 입력순서 바뀜
anova(fit2)
Reduced <- lm(Salary ~ Hits + HmRun, data = Hitters)
anova(Reduced, fit)
library(car)
library(car)
Anova(lm(Salary ~ AtBat + Hits + HmRun, data = Hitters), type = "II")
library(ellipsis)
lm.fit <- lm(Salary ~ HmRun, data = Hitters)
# 100 (1-alpha)% 공동신뢰영역(joint confidence region)
alpha <- 0.05
joint_conf <- ellipse(lm.fit, which = c(1,2), level = 1 - alpha_hat)
library(ellipsis)
lm.fit <- lm(Salary ~ HmRun, data = Hitters)
# 100 (1-alpha)% 공동신뢰영역(joint confidence region)
alpha <- 0.05
joint_conf <- ellipse(lm.fit, which = c(1,2), level = 1 - alpha)
library(ellipsis)
fit <- lm(Salary ~ HmRun, data = Hitters)
# 100 (1-alpha)% 공동신뢰영역(joint confidence region)
alpha <- 0.05
joint_conf <- ellipse(lm.fit, which = c(1,2), level = 1 - alpha)
library(ellipsis)
lm.fit <- lm(Salary ~ HmRun, data = Hitters)
# 100 (1-alpha)% 공동신뢰영역(joint confidence region)
alpha <- 0.05
joint_conf <- ellipse(lm.fit, which = c(1,2), level = 1 - alpha)
library(ellipse)
install.packages("ellipse")
library(ellipse)
lm.fit <- lm(Salary ~ HmRun, data = Hitters)
# 100 (1-alpha)% 공동신뢰영역(joint confidence region)
alpha <- 0.05
joint_conf <- ellipse(lm.fit, which = c(1,2), level = 1 - alpha)
plot(joint_conf, type = "l", col = "blue", lwd = 2,
xlim = c(200, 450), ylim = c(5, 30), cex.main = 1.5,
xlab = "Intercept", ylab = "HmRun",
main = "Joint and Simultaneous Confidence Regions")
points(lm.fit$coefficients[1], lm.fit$coefficients[2],
lwd = 3, pch = 4, col = "blue")
# 본페로니 동시 신뢰구간
Bonferroni_conf = confint(lm.fit, level = 1 - alpha/2)
int_lower = Bonferroni_conf[1, 1]
int_upper = Bonferroni_conf[1, 2]
HmRun_lower = Bonferroni_conf[2, 1]
HmRun_upper = Bonferroni_conf[2, 2]
# Bonferroni simultaneous confidence interval for beta_0
abline(v = c(int_lower, int_upper), col = "red", lwd = 2)
library(ellipse)
lm.fit <- lm(Salary ~ HmRun, data = Hitters)
# 100 (1-alpha)% 공동신뢰영역(joint confidence region)
alpha <- 0.05
joint_conf <- ellipse(lm.fit, which = c(1,2), level = 1 - alpha)
plot(joint_conf, type = "l", col = "blue", lwd = 2,
xlim = c(200, 450), ylim = c(5, 30), cex.main = 1.5,
xlab = "Intercept", ylab = "HmRun",
main = "Joint and Simultaneous Confidence Regions")
points(lm.fit$coefficients[1], lm.fit$coefficients[2],
lwd = 3, pch = 4, col = "blue")
# 본페로니 동시 신뢰구간
Bonferroni_conf = confint(lm.fit, level = 1 - alpha/2)
int_lower = Bonferroni_conf[1, 1]
int_upper = Bonferroni_conf[1, 2]
HmRun_lower = Bonferroni_conf[2, 1]
HmRun_upper = Bonferroni_conf[2, 2]
# Bonferroni simultaneous confidence interval for beta_0
abline(v = c(int_lower, int_upper), col = "red", lwd = 2)
# Bonferroni simultaneous confidence interval for beta_1
abline(v = c(HmRun_lower, HmRun_upper), col = "red", lwd = 2)
library(ellipse)
lm.fit <- lm(Salary ~ HmRun, data = Hitters)
# 100 (1-alpha)% 공동신뢰영역(joint confidence region)
alpha <- 0.05
joint_conf <- ellipse(lm.fit, which = c(1,2), level = 1 - alpha)
plot(joint_conf, type = "l", col = "blue", lwd = 2,
xlim = c(200, 450), ylim = c(5, 30), cex.main = 1.5,
xlab = "Intercept", ylab = "HmRun",
main = "Joint and Simultaneous Confidence Regions")
points(lm.fit$coefficients[1], lm.fit$coefficients[2],
lwd = 3, pch = 4, col = "blue")
# 본페로니 동시 신뢰구간
Bonferroni_conf = confint(lm.fit, level = 1 - alpha/2)
int_lower = Bonferroni_conf[1, 1]
int_upper = Bonferroni_conf[1, 2]
HmRun_lower = Bonferroni_conf[2, 1]
HmRun_upper = Bonferroni_conf[2, 2]
# Bonferroni simultaneous confidence interval for beta_0
abline(v = c(int_lower, int_upper), col = "red", lwd = 2)
# Bonferroni simultaneous confidence interval for beta_1
abline(h = c(HmRun_lower, HmRun_upper), col = "red", lwd = 2)
