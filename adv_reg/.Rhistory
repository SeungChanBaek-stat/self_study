SS_beta1_beta0_hat = ASS_calc(X = X, y = y, index_sol = c(1), index_given = c(0), coef = TRUE)
SS_beta1_beta0beta2_hat = ASS_calc(X = X, y = y, index_sol = c(1), index_given = c(0,2), coef = TRUE)
alpha = 0.05 ; n = length(y) ; p = dim(X)[2]
mult_res = mult_reg(X, y)
MSE = mult_res$MSE ; MSE
F_0 = SS_beta1_beta0beta2_hat / MSE
F_alpha = qf(alpha, 1, n-p-1, lower.tail = FALSE)
F_0 ; F_alpha
alpha = 0.05 ; n = length(y) ; p = dim(X)[2]
mult_res = mult_reg(X, y)
MSE = mult_res$MSE
SS_beta2_beta0beta1_hat = ASS_calc(X = X, y = y, index_sol = c(2), index_given = c(0,1), coef = TRUE)
F_0 = SS_beta2_beta0beta1_hat / MSE ; F_alpha = qf(alpha, 1, n-p-1, lower.tail = FALSE)
F_0 ; F_alpha
SS_beta2_beta0_hat = ASS_calc(X = X, y = y, index_sol = c(2), index_given = c(0), coef = TRUE)
F_0 = SS_beta2_beta0_hat / MSE ; F_alpha = qf(alpha, 1, n-p-1, lower.tail = FALSE)
F_0 ; F_alpha
x1 = c(10, 24, 25, 28, 15, 18, 22, 22, 12, 15)
x2 = c(27, 26, 28, 26, 30, 24, 27, 25, 27, 25) ; x3 = c(64, 72, 80, 88, 81, 45, 46, 69, 54, 39)
X = cbind(x1, x2, x3) ; y = c(2.8, 3.9, 3.9, 4.4, 3.1, 3.1, 3.5, 3.6, 3.0, 3.3)
standard_res = standard_calc(X, y)
Z = standard_res$Z ; ystar = standard_res$ystar
alpha_hat = solve(t(Z) %*% Z) %*% t(Z) %*% ystar ; alpha_hat
corr_matrix = t(Z) %*% Z ; corr_matrix
S_jj = standard_res$S_jj ; S_yy = standard_res$S_yy ; xbar = standard_res$xbar ; ybar = standard_res$ybar
beta_hat = alpha_hat * sqrt(S_yy / S_jj) ; beta_hat
beta0_hat = ybar - t(xbar) %*% beta_hat ; beta0_hat
x_0 = c(rep(1, 14)) ; x_1 = c(3, 1, 5, 8, 1, 4, 2, 6, 9, 3, 5, 7, 2, 6)
y = c(39, 24, 115, 105, 50, 86, 67, 90, 140, 112, 70, 186, 43, 126)
n = length(x_0) ; X = cbind(x_0, x_1) ; p = dim(X)[2] - 1 ; alpha = 0.05
XtX = t(X) %*% X
beta_hat = solve(XtX) %*% t(X) %*% y ; beta_hat
SSE = t(y) %*% y - t(beta_hat) %*% t(X) %*% y
MSE = SSE / (n - p - 1)
F_alpha = qf(alpha, p+1, n-p-1, lower.tail = FALSE)
# 타원에 해당하는 상수
c_val <- (p + 1) * MSE * F_alpha
# (XtX)^{-1}의 제곱근을 구하기 위해 고유분해 사용
A <- solve(XtX)
eig_A <- eigen(A)
A_sqrt <- eig_A$vectors %*% diag(sqrt(eig_A$values)) %*% t(eig_A$vectors)
# 0~2pi 범위의 각도 생성
theta <- seq(0, 2 * pi, length.out = 100)
# 각 theta에 대해 타원 위의 점 계산
ellipse_coords <- t(sapply(theta, function(t) {
# cat("beta_hat", dim(beta_hat) ,"c_val",  dim(c_val) ,"A_sqrt", dim(A_sqrt))
beta_hat + as.numeric(sqrt(c_val)) * A_sqrt %*% c(cos(t), sin(t))
}))
# 타원과 중심(beta_hat) 그리기
plot(ellipse_coords, type = "l",
xlab = expression(beta[0]), ylab = expression(beta[1]),
main = "신뢰영역 (타원) for beta")
points(beta_hat[1], beta_hat[2], col = "red", pch = 19)
x1 = c(195, 179, 205, 204, 201, 184, 210, 209) ; x2 = c(57, 61, 60, 62, 61, 54, 58, 61)
y = c(81.4, 122.2, 101.7, 175.6, 150.3, 64.8, 92.1, 113.8) ; X = cbind(x1, x2)
n = dim(X)[1] ; p = dim(X)[2] ; alpha = 0.1
mult_res = mult_reg(X, y, coeff = FALSE)
beta_hat = mult_res$beta_hat ; XtX = mult_res$XtX ; MSE = mult_res$MSE
beta_hat ; MSE
F_alpha = qf(alpha, p, n-p, lower.tail = FALSE)
# 타원에 해당하는 상수
c_val <- (p + 1) * MSE * F_alpha
# (XtX)^{-1}의 제곱근을 구하기 위해 고유분해 사용
A <- solve(XtX)
eig_A <- eigen(A)
A_sqrt <- eig_A$vectors %*% diag(sqrt(eig_A$values)) %*% t(eig_A$vectors)
# 0~2pi 범위의 각도 생성
theta <- seq(0, 2 * pi, length.out = 100)
# 각 theta에 대해 타원 위의 점 계산
ellipse_coords <- t(sapply(theta, function(t) {
# cat("beta_hat", dim(beta_hat) ,"c_val",  dim(c_val) ,"A_sqrt", dim(A_sqrt))
beta_hat + as.numeric(sqrt(c_val)) * A_sqrt %*% c(cos(t), sin(t))
}))
# 타원과 중심(beta_hat) 그리기
plot(ellipse_coords, type = "l",
xlab = expression(beta[1]), ylab = expression(beta[2]),
main = "신뢰영역 (타원) for beta")
points(beta_hat[1], beta_hat[2], col = "red", pch = 19)
x11 = c(4, 8, 9, 8, 8, 12, 6, 10, 6, 9) ; x12 = c(4, 10, 8, 5, 10, 15, 8, 13, 5, 12)
y1 = c(9, 20, 22, 15, 17, 30, 18, 25, 10, 20) ; X1 = cbind(x11, x12)
x21 = c(13, 10, 9, 15, 12, 14, 10, 7, 8, 7) ; x22 = c(12, 8, 8, 14, 13, 10, 8, 7, 10, 9)
y2 = c(25, 20, 18, 35, 30, 32, 27, 20, 20, 19) ; X2 = cbind(x21, x22)
x1 = c(x11, x21) ; x2 = c(x12, x22) ; y = c(y1, y2) ; X = cbind(x1, x2)
n1 = dim(X1)[1] ; p = dim(X2)[2] ; n2 = dim(X2)[1] ; n = n1+n2
full_model1 = mult_reg(X1, y1, alpha = 0.05, coeff = TRUE)
full_model2 = mult_reg(X2, y2, alpha = 0.05, coeff = TRUE)
Reduced_model = mult_reg(X, y, alpha = 0.05, coeff = TRUE)
SSE_1 = full_model1$SSE ; SSE_2 = full_model2$SSE
SSE_F = SSE_1 + SSE_2 ; SSE_R = Reduced_model$SSE
df_F = n - 2*p - 2 ; df_R = n - p - 1 ; alpha = 0.05
F_0 = ((SSE_R - SSE_F)/(df_R - df_F)) / (SSE_F / df_F)
F_alpha = qf(alpha, df_R - df_F, df_F, lower.tail = FALSE)
F_0 ; F_alpha
SS_1_02 = ASS_calc(X2, y2, index_sol = c(1), index_given = c(0, 2), coef = TRUE)
SS_2_01 = ASS_calc(X2, y2, index_sol = c(2), index_given = c(0, 1), coef = TRUE)
beta2_hat = full_model2$beta_hat ; MSE2 = full_model2$MSE
X2tX2 = full_model2$XtX ; F_alpha = qf(0.1, p+1, n2 - p - 1, lower.tail = FALSE)
beta2_hat ; MSE2 ; X2tX2 ; F_alpha
beta2_null = c(0,2,1)
Tbeta2 = t(beta2_null - beta2_hat) %*% X2tX2 %*% (beta2_null - beta2_hat) - (p+1) * MSE2 * F_alpha
Tbeta2
x1 = c(1,2,3,1,2,3) ; x2 = c(-1,-1,-1,1,1,1) ; x3 = c(-1,0,1,1,0,-1)
y = c(7,8,10,15,18,26) ; X = cbind(x1,x2,x3) ; n = dim(X)[1] ; p = dim(X)[2] ; alpha = 0.05
one = c(rep(1,n)) ; X = cbind(one, X)
XtX_inv = solve(t(X) %*% X) ; Xty = t(X) %*% y ; yty = t(y) %*% y
beta_hat = XtX_inv %*% Xty
SSR = t(beta_hat) %*% Xty ; SSE = yty - t(beta_hat) %*% Xty ; SST = yty
df_SSR = p ; df_SSE = n - p ; df_total = n
MSR = SSR / df_SSR ; MSE = SSE / df_SSE
F_0 = MSR / MSE ; F_alpha = qf(alpha, df_SSR, df_SSE, lower.tail = FALSE)
anova_table = data.frame(
요인 = c("회귀", "잔차", "계"),
제곱합 = c(SSR, SSE, SST),
자유도 = c(df_SSR, df_SSE, df_total),
평균제곱합 = c(MSR, MSE, NA),
F_0 = c(F_0, NA, NA),
F_alpha = c(F_alpha, NA, NA)
)
beta_hat
print(anova_table)
one = c(rep(1,n)) ; X = cbind(one, X)
XtX_inv = solve(t(X) %*% X) ; Xty = t(X) %*% y ; yty = t(y) %*% y
x1 = c(1,2,3,1,2,3) ; x2 = c(-1,-1,-1,1,1,1) ; x3 = c(-1,0,1,1,0,-1)
y = c(7,8,10,15,18,26) ; X = cbind(x1,x2,x3) ; n = dim(X)[1] ; p = dim(X)[2] ; alpha = 0.05
one = c(rep(1,n)) ; X = cbind(one, X)
XtX_inv = solve(t(X) %*% X) ; Xty = t(X) %*% y ; yty = t(y) %*% y
beta_hat = XtX_inv %*% Xty
SSR = t(beta_hat) %*% Xty ; SSE = yty - t(beta_hat) %*% Xty ; SST = yty
df_SSR = p+1 ; df_SSE = n-p-1 ; df_total = n
MSR = SSR / df_SSR ; MSE = SSE / df_SSE
F_0 = MSR / MSE ; F_alpha = qf(alpha, df_SSR, df_SSE, lower.tail = FALSE)
anova_table = data.frame(
요인 = c("회귀", "잔차", "계"),
제곱합 = c(SSR, SSE, SST),
자유도 = c(df_SSR, df_SSE, df_total),
평균제곱합 = c(MSR, MSE, NA),
F_0 = c(F_0, NA, NA),
F_alpha = c(F_alpha, NA, NA)
)
beta_hat
print(anova_table)
x1 = c(1,2,3,1,2,3) ; x2 = c(-1,-1,-1,1,1,1) ; x3 = c(-1,0,1,1,0,-1)
y = c(7,8,10,15,18,26) ; X = cbind(x1,x2,x3) ; n = dim(X)[1] ; p = dim(X)[2] ; alpha = 0.05
one = c(rep(1,n)) ; X = cbind(one, X)
XtX_inv = solve(t(X) %*% X) ; Xty = t(X) %*% y ; yty = t(y) %*% y
beta_hat = XtX_inv %*% Xty
SSR = t(beta_hat) %*% Xty ; SSE = yty - t(beta_hat) %*% Xty ; SST = yty
df_SSR = p+1 ; df_SSE = n-p-1 ; df_total = n
MSR = SSR / df_SSR ; MSE = SSE / df_SSE
F_0 = MSR / MSE ; F_alpha = qf(alpha, df_SSR, df_SSE, lower.tail = FALSE)
anova_table = data.frame(
요인 = c("회귀", "잔차", "계"),
제곱합 = c(SSR, SSE, SST),
자유도 = c(df_SSR, df_SSE, df_total),
평균제곱합 = c(MSR, MSE, NA),
F_0 = c(F_0, NA, NA),
F_alpha = c(F_alpha, NA, NA)
)
beta_hat
SS_1_023 = ASS_calc(X = X, y = y, index_sol = c(1), index_given = c(0,2,3), coef = TRUE)
x1 = c(1,2,3,1,2,3) ; x2 = c(-1,-1,-1,1,1,1) ; x3 = c(-1,0,1,1,0,-1)
y = c(7,8,10,15,18,26) ; X = cbind(x1,x2,x3) ; n = dim(X)[1] ; p = dim(X)[2] ; alpha = 0.05
one = c(rep(1,n)) ; X = cbind(one, X)
XtX_inv = solve(t(X) %*% X) ; Xty = t(X) %*% y ; yty = t(y) %*% y
beta_hat = XtX_inv %*% Xty
SSR = t(beta_hat) %*% Xty ; SSE = yty - t(beta_hat) %*% Xty ; SST = yty
df_SSR = p+1 ; df_SSE = n-p-1 ; df_total = n
MSR = SSR / df_SSR ; MSE = SSE / df_SSE
F_0 = MSR / MSE ; F_alpha = qf(alpha, df_SSR, df_SSE, lower.tail = FALSE)
anova_table = data.frame(
요인 = c("회귀", "잔차", "계"),
제곱합 = c(SSR, SSE, SST),
자유도 = c(df_SSR, df_SSE, df_total),
평균제곱합 = c(MSR, MSE, NA),
F_0 = c(F_0, NA, NA),
F_alpha = c(F_alpha, NA, NA)
)
beta_hat
SS_1_023 = ASS_calc(X = X, y = y, index_sol = c(1), index_given = c(0,2,3), coef = TRUE)
SS_1_02 = ASS_calc(X = X, y = y, index_sol = c(1), index_given = c(0,2), coef = TRUE)
source("functions/mult_reg.R")
x1 = c(1,2,3,1,2,3) ; x2 = c(-1,-1,-1,1,1,1) ; x3 = c(-1,0,1,1,0,-1)
y = c(7,8,10,15,18,26) ; X = cbind(x1,x2,x3) ; n = dim(X)[1] ; p = dim(X)[2] ; alpha = 0.05
source("functions/mult_reg.R")
one = c(rep(1,n)) ; X = cbind(one, X)
XtX_inv = solve(t(X) %*% X) ; Xty = t(X) %*% y ; yty = t(y) %*% y
beta_hat = XtX_inv %*% Xty
SSR = t(beta_hat) %*% Xty ; SSE = yty - t(beta_hat) %*% Xty ; SST = yty
df_SSR = p+1 ; df_SSE = n-p-1 ; df_total = n
MSR = SSR / df_SSR ; MSE = SSE / df_SSE
F_0 = MSR / MSE ; F_alpha = qf(alpha, df_SSR, df_SSE, lower.tail = FALSE)
anova_table = data.frame(
요인 = c("회귀", "잔차", "계"),
제곱합 = c(SSR, SSE, SST),
자유도 = c(df_SSR, df_SSE, df_total),
평균제곱합 = c(MSR, MSE, NA),
F_0 = c(F_0, NA, NA),
F_alpha = c(F_alpha, NA, NA)
)
beta_hat
SS_1_023 = ASS_calc(X = X, y = y, index_sol = c(1), index_given = c(0,2,3), coef = TRUE)
x1 = c(1,2,3,1,2,3) ; x2 = c(-1,-1,-1,1,1,1) ; x3 = c(-1,0,1,1,0,-1)
y = c(7,8,10,15,18,26) ; X = cbind(x1,x2,x3) ; n = dim(X)[1] ; p = dim(X)[2] ; alpha = 0.05
source("functions/mult_reg.R")
one = c(rep(1,n)) ; X = cbind(one, X)
XtX_inv = solve(t(X) %*% X) ; Xty = t(X) %*% y ; yty = t(y) %*% y
beta_hat = XtX_inv %*% Xty
SSR = t(beta_hat) %*% Xty ; SSE = yty - t(beta_hat) %*% Xty ; SST = yty
df_SSR = p+1 ; df_SSE = n-p-1 ; df_total = n
MSR = SSR / df_SSR ; MSE = SSE / df_SSE
F_0 = MSR / MSE ; F_alpha = qf(alpha, df_SSR, df_SSE, lower.tail = FALSE)
anova_table = data.frame(
요인 = c("회귀", "잔차", "계"),
제곱합 = c(SSR, SSE, SST),
자유도 = c(df_SSR, df_SSE, df_total),
평균제곱합 = c(MSR, MSE, NA),
F_0 = c(F_0, NA, NA),
F_alpha = c(F_alpha, NA, NA)
)
beta_hat
SS_1_023 = ASS_calc(X = X, y = y, index_sol = c(1), index_given = c(0,2,3), coef = TRUE)
x1 = c(1,2,3,1,2,3) ; x2 = c(-1,-1,-1,1,1,1) ; x3 = c(-1,0,1,1,0,-1)
y = c(7,8,10,15,18,26) ; X = cbind(x1,x2,x3) ; n = dim(X)[1] ; p = dim(X)[2] ; alpha = 0.05
source("functions/mult_reg.R")
one = c(rep(1,n)) ; X = cbind(one, X)
XtX_inv = solve(t(X) %*% X) ; Xty = t(X) %*% y ; yty = t(y) %*% y
beta_hat = XtX_inv %*% Xty
SSR = t(beta_hat) %*% Xty ; SSE = yty - t(beta_hat) %*% Xty ; SST = yty
df_SSR = p+1 ; df_SSE = n-p-1 ; df_total = n
MSR = SSR / df_SSR ; MSE = SSE / df_SSE
F_0 = MSR / MSE ; F_alpha = qf(alpha, df_SSR, df_SSE, lower.tail = FALSE)
anova_table = data.frame(
요인 = c("회귀", "잔차", "계"),
제곱합 = c(SSR, SSE, SST),
자유도 = c(df_SSR, df_SSE, df_total),
평균제곱합 = c(MSR, MSE, NA),
F_0 = c(F_0, NA, NA),
F_alpha = c(F_alpha, NA, NA)
)
beta_hat
print(anova_table)
x1 = c(1,2,3,1,2,3) ; x2 = c(-1,-1,-1,1,1,1) ; x3 = c(-1,0,1,1,0,-1)
y = c(7,8,10,15,18,26) ; X = cbind(x1,x2,x3) ; n = dim(X)[1] ; p = dim(X)[2] ; alpha = 0.05
SS_1_023 = ASS_calc(X = X, y = y, index_sol = c(1), index_given = c(0,2,3), coef = TRUE)
SS_1_02 = ASS_calc(X = X, y = y, index_sol = c(1), index_given = c(0,2), coef = TRUE)
x1 = c(1,2,3,1,2,3) ; x2 = c(-1,-1,-1,1,1,1) ; x3 = c(-1,0,1,1,0,-1)
y = c(7,8,10,15,18,26) ; X = cbind(x1,x2,x3) ; n = dim(X)[1] ; p = dim(X)[2] ; alpha = 0.05
one = c(rep(1,n)) ; X = cbind(one, X)
XtX_inv = solve(t(X) %*% X) ; Xty = t(X) %*% y ; yty = t(y) %*% y
beta_hat = XtX_inv %*% Xty
SSR = t(beta_hat) %*% Xty ; SSE = yty - t(beta_hat) %*% Xty ; SST = yty
df_SSR = p + 1 ; df_SSE = n - p - 1 ; df_total = n
MSR = SSR / df_SSR ; MSE = SSE / df_SSE
F_0 = MSR / MSE ; F_alpha = qf(alpha, df_SSR, df_SSE, lower.tail = FALSE)
anova_table = data.frame(
요인 = c("회귀", "잔차", "계"),
제곱합 = c(SSR, SSE, SST),
자유도 = c(df_SSR, df_SSE, df_total),
평균제곱합 = c(MSR, MSE, NA),
F_0 = c(F_0, NA, NA),
F_alpha = c(F_alpha, NA, NA)
)
beta_hat
print(anova_table)
beta_hat = XtX_inv %*% Xty ; X_R = X[,-c(2)] # X_R = X[,-c(2)] 와 X_R = X[,c(1, 3, 4)] 는 동일하다.
beta_hat_R = solve(t(X_R) %*% X_R) %*% t(X_R) %*% y
SS_F = t(beta_hat) %*% Xty
SS_R = t(beta_hat_R) %*% t(X_R) %*% y
SS_F - SS_R
F_0 = ((SS_F - SS_R)/(p - 2)) / (MSE) ; F_0
F_alpha = qf(alpha,p-2, n-p-1, lower.tail = FALSE) ; F_alpha
library(glue)
index = c(1,2)
X_1 = X[,index] ; X_2 = X[, -index]
beta1_hat = solve(t(X_1) %*% X_1) %*% t(X_1) %*% y
beta2_hat = solve(t(X_2) %*% X_2) %*% t(X_2) %*% y
beta_hat = solve(t(X) %*% X) %*% t(X) %*% y
SS_beta1_hat = t(beta1_hat) %*% t(X_1) %*% y
SS_beta2_hat = t(beta2_hat) %*% t(X_2) %*% y
SS_beta_hat = t(beta_hat) %*% t(X) %*% y
print(glue("SS_beta1_hat = {SS_beta1_hat}, SS_beta2_hat = {SS_beta2_hat}, SS_beta_hat = {SS_beta_hat}"))
x1 = c(1,2,3,4,5,6,7) ; x2 = c(-1,-1,-1,1,1,1,0) ; x3 = c(-1,0,1,-1,0,1,0)
y = c(7, 8, 10, 15, 18, 19, 14) ; X = cbind(x1,x2,x3) ; n = dim(X)[1] ; p = dim(X)[2]
one = c(rep(1,n)) ; X = cbind(one, X)
x1bar = mean(x1) ; x2bar = mean(x2) ; x3bar = mean(x3) ; ybar = mean(y)
S_11 = sum((x1 - x1bar)^2) ; S_22 = sum((x2 - x2bar)^2) ; S_33 = sum((x3 - x3bar)^2) ; S_yy = sum((y - ybar)^2)
z1 = (x1 - x1bar)/sqrt(S_11) ; z2 = (x2 - x2bar)/sqrt(S_22) ; z3 = (x3 - x3bar)/sqrt(S_33) ; ystar = (y - ybar)/sqrt(S_yy)
Z = cbind(z1,z2,z3) ; ZtZ = t(Z) %*% Z ; Ztystar = t(Z) %*% ystar
Z
ZtZ
Ztystar
alpha_hat = solve(ZtZ) %*% Ztystar ; alpha_hat
temp = c(sqrt(S_yy / S_11), sqrt(S_yy / S_22), sqrt(S_yy / S_33))
beta_hat = alpha_hat * as.vector(temp) ; beta_hat
xbar = c(x1bar, x2bar, x3bar)
beta0_hat = ybar - t(xbar) %*% beta_hat ; beta0_hat
var_alpha_hat = solve(ZtZ) ; var_alpha_hat
x = c(30, 20, 60, 80, 40, 50, 60, 30, 70, 60)
y = c(73, 50, 128, 170, 97, 108, 135, 69, 148, 132)
n = length(x) ; one = c(rep(1,n)) ; X = cbind(one, x) ; p = 1
beta_hat = solve(t(X) %*% X) %*% t(X) %*% y ; beta_hat
SSE = t(y) %*% y - t(beta_hat) %*% t(X) %*% y ; SSE
MSE = SSE/(n-p-1) ; MSE
XtX = t(X) %*% X ; XtX
F_alpha = qf(0.05, p+1, n-p-1, lower.tail = FALSE) ; F_alpha
D = det(XtX) ; D
XtX_inv = solve(XtX) ; XtX_inv
var_hat_beta0_hat = XtX_inv[1,1] * MSE ; var_hat_beta0_hat
cov_hat_beta0beta1_hat = XtX_inv[1,2] * MSE ; cov_hat_beta0beta1_hat
var_hat_beta1_hat = XtX_inv[2,2] * MSE ; var_hat_beta1_hat
# 타원에 해당하는 상수
c_val <- (p + 1) * MSE * F_alpha
# (XtX)^{-1}의 제곱근을 구하기 위해 고유분해 사용
A <- solve(XtX)
eig_A <- eigen(A)
A_sqrt <- eig_A$vectors %*% diag(sqrt(eig_A$values)) %*% t(eig_A$vectors)
# 0~2pi 범위의 각도 생성
theta <- seq(0, 2 * pi, length.out = 100)
# 각 theta에 대해 타원 위의 점 계산
ellipse_coords <- t(sapply(theta, function(t) {
# cat("beta_hat", dim(beta_hat) ,"c_val",  dim(c_val) ,"A_sqrt", dim(A_sqrt))
beta_hat + as.numeric(sqrt(c_val)) * A_sqrt %*% c(cos(t), sin(t))
}))
# 타원과 중심(beta_hat) 그리기
plot(ellipse_coords, type = "l",
xlab = expression(beta[0]), ylab = expression(beta[1]),
main = "신뢰영역 (타원) for beta")
points(beta_hat[1], beta_hat[2], col = "red", pch = 19)
library(ISLR)
# install.packages("dplyr")
library(dplyr)
data(Hitters)
Hitters = Hitters %>% na.omit() %>% select(AtBat, Hits, HmRun, Salary)
fit <- lm(Salary ~ AtBat + Hits + HmRun, data = Hitters)
anova(fit)
fit2 <- lm(Salary ~ Hits + HmRun + AtBat, data = Hitters) # 설명변수 입력순서 바뀜
anova(fit2)
Reduced <- lm(Salary ~ Hits + HmRun, data = Hitters)
anova(Reduced, fit)
library(car)
Anova(lm(Salary ~ AtBat + Hits + HmRun, data = Hitters), type = "II")
library(ellipse)
lm.fit <- lm(Salary ~ HmRun, data = Hitters)
# 100 (1-alpha)% 공동신뢰영역(joint confidence region)
alpha <- 0.05
joint_conf <- ellipse(lm.fit, which = c(1,2), level = 1 - alpha)
plot(joint_conf, type = "l", col = "blue", lwd = 2,
xlim = c(200, 450), ylim = c(5, 30), cex.main = 1.5,
xlab = "Intercept", ylab = "HmRun",
main = "Joint and Simultaneous Confidence Regions")
points(lm.fit$coefficients[1], lm.fit$coefficients[2],
lwd = 3, pch = 4, col = "blue")
# 본페로니 동시 신뢰구간
Bonferroni_conf = confint(lm.fit, level = 1 - alpha/2)
int_lower = Bonferroni_conf[1, 1]
int_upper = Bonferroni_conf[1, 2]
HmRun_lower = Bonferroni_conf[2, 1]
HmRun_upper = Bonferroni_conf[2, 2]
# Bonferroni simultaneous confidence interval for beta_0
abline(v = c(int_lower, int_upper), col = "red", lwd = 2)
# Bonferroni simultaneous confidence interval for beta_1
abline(h = c(HmRun_lower, HmRun_upper), col = "red", lwd = 2)
x1 = c(195, 179, 205, 204, 201, 184, 210, 209) ; x2 = c(57, 61, 60, 62, 61, 54, 58, 61)
y = c(81.4, 122.2, 101.7, 175.6, 150.3, 64.8, 92.1, 113.8) ; X = cbind(x1, x2)
source("functions/mult_reg.R", echo=TRUE)
SS_beta1_hat = ASS_calc(X = X, y = y, index_sol = c(1), index_given = NA, coef = TRUE)
SS_beta1_beta0_hat = ASS_calc(X = X, y = y, index_sol = c(1), index_given = c(0), coef = TRUE)
SS_beta1_beta0beta2_hat = ASS_calc(X = X, y = y, index_sol = c(1), index_given = c(0,2), coef = TRUE)
alpha = 0.05 ; n = length(y) ; p = dim(X)[2]
mult_res = mult_reg(X, y)
MSE = mult_res$MSE ; MSE
F_0 = SS_beta1_beta0beta2_hat / MSE
F_alpha = qf(alpha, 1, n-p-1, lower.tail = FALSE)
F_0 ; F_alpha
alpha = 0.05 ; n = length(y) ; p = dim(X)[2]
mult_res = mult_reg(X, y)
MSE = mult_res$MSE
SS_beta2_beta0beta1_hat = ASS_calc(X = X, y = y, index_sol = c(2), index_given = c(0,1), coef = TRUE)
F_0 = SS_beta2_beta0beta1_hat / MSE ; F_alpha = qf(alpha, 1, n-p-1, lower.tail = FALSE)
F_0 ; F_alpha
SS_beta2_beta0_hat = ASS_calc(X = X, y = y, index_sol = c(2), index_given = c(0), coef = TRUE)
F_0 = SS_beta2_beta0_hat / MSE ; F_alpha = qf(alpha, 1, n-p-1, lower.tail = FALSE)
F_0 ; F_alpha
x1 = c(10, 24, 25, 28, 15, 18, 22, 22, 12, 15)
x2 = c(27, 26, 28, 26, 30, 24, 27, 25, 27, 25) ; x3 = c(64, 72, 80, 88, 81, 45, 46, 69, 54, 39)
X = cbind(x1, x2, x3) ; y = c(2.8, 3.9, 3.9, 4.4, 3.1, 3.1, 3.5, 3.6, 3.0, 3.3)
standard_res = standard_calc(X, y)
Z = standard_res$Z ; ystar = standard_res$ystar
alpha_hat = solve(t(Z) %*% Z) %*% t(Z) %*% ystar ; alpha_hat
corr_matrix = t(Z) %*% Z ; corr_matrix
S_jj = standard_res$S_jj ; S_yy = standard_res$S_yy ; xbar = standard_res$xbar ; ybar = standard_res$ybar
beta_hat = alpha_hat * sqrt(S_yy / S_jj) ; beta_hat
beta0_hat = ybar - t(xbar) %*% beta_hat ; beta0_hat
x_0 = c(rep(1, 14)) ; x_1 = c(3, 1, 5, 8, 1, 4, 2, 6, 9, 3, 5, 7, 2, 6)
y = c(39, 24, 115, 105, 50, 86, 67, 90, 140, 112, 70, 186, 43, 126)
n = length(x_0) ; X = cbind(x_0, x_1) ; p = dim(X)[2] - 1 ; alpha = 0.05
XtX = t(X) %*% X
beta_hat = solve(XtX) %*% t(X) %*% y ; beta_hat
SSE = t(y) %*% y - t(beta_hat) %*% t(X) %*% y
MSE = SSE / (n - p - 1)
F_alpha = qf(alpha, p+1, n-p-1, lower.tail = FALSE)
# 타원에 해당하는 상수
c_val <- (p + 1) * MSE * F_alpha
# (XtX)^{-1}의 제곱근을 구하기 위해 고유분해 사용
A <- solve(XtX)
eig_A <- eigen(A)
A_sqrt <- eig_A$vectors %*% diag(sqrt(eig_A$values)) %*% t(eig_A$vectors)
# 0~2pi 범위의 각도 생성
theta <- seq(0, 2 * pi, length.out = 100)
# 각 theta에 대해 타원 위의 점 계산
ellipse_coords <- t(sapply(theta, function(t) {
# cat("beta_hat", dim(beta_hat) ,"c_val",  dim(c_val) ,"A_sqrt", dim(A_sqrt))
beta_hat + as.numeric(sqrt(c_val)) * A_sqrt %*% c(cos(t), sin(t))
}))
# 타원과 중심(beta_hat) 그리기
plot(ellipse_coords, type = "l",
xlab = expression(beta[0]), ylab = expression(beta[1]),
main = "신뢰영역 (타원) for beta")
points(beta_hat[1], beta_hat[2], col = "red", pch = 19)
x1 = c(195, 179, 205, 204, 201, 184, 210, 209) ; x2 = c(57, 61, 60, 62, 61, 54, 58, 61)
y = c(81.4, 122.2, 101.7, 175.6, 150.3, 64.8, 92.1, 113.8) ; X = cbind(x1, x2)
n = dim(X)[1] ; p = dim(X)[2] ; alpha = 0.1
mult_res = mult_reg(X, y, coeff = FALSE)
beta_hat = mult_res$beta_hat ; XtX = mult_res$XtX ; MSE = mult_res$MSE
beta_hat ; MSE
F_alpha = qf(alpha, p, n-p, lower.tail = FALSE)
# 타원에 해당하는 상수
c_val <- (p + 1) * MSE * F_alpha
# (XtX)^{-1}의 제곱근을 구하기 위해 고유분해 사용
A <- solve(XtX)
eig_A <- eigen(A)
A_sqrt <- eig_A$vectors %*% diag(sqrt(eig_A$values)) %*% t(eig_A$vectors)
# 0~2pi 범위의 각도 생성
theta <- seq(0, 2 * pi, length.out = 100)
# 각 theta에 대해 타원 위의 점 계산
ellipse_coords <- t(sapply(theta, function(t) {
# cat("beta_hat", dim(beta_hat) ,"c_val",  dim(c_val) ,"A_sqrt", dim(A_sqrt))
beta_hat + as.numeric(sqrt(c_val)) * A_sqrt %*% c(cos(t), sin(t))
}))
# 타원과 중심(beta_hat) 그리기
plot(ellipse_coords, type = "l",
xlab = expression(beta[1]), ylab = expression(beta[2]),
main = "신뢰영역 (타원) for beta")
points(beta_hat[1], beta_hat[2], col = "red", pch = 19)
x11 = c(4, 8, 9, 8, 8, 12, 6, 10, 6, 9) ; x12 = c(4, 10, 8, 5, 10, 15, 8, 13, 5, 12)
y1 = c(9, 20, 22, 15, 17, 30, 18, 25, 10, 20) ; X1 = cbind(x11, x12)
x21 = c(13, 10, 9, 15, 12, 14, 10, 7, 8, 7) ; x22 = c(12, 8, 8, 14, 13, 10, 8, 7, 10, 9)
y2 = c(25, 20, 18, 35, 30, 32, 27, 20, 20, 19) ; X2 = cbind(x21, x22)
x1 = c(x11, x21) ; x2 = c(x12, x22) ; y = c(y1, y2) ; X = cbind(x1, x2)
n1 = dim(X1)[1] ; p = dim(X2)[2] ; n2 = dim(X2)[1] ; n = n1+n2
full_model1 = mult_reg(X1, y1, alpha = 0.05, coeff = TRUE)
full_model2 = mult_reg(X2, y2, alpha = 0.05, coeff = TRUE)
Reduced_model = mult_reg(X, y, alpha = 0.05, coeff = TRUE)
SSE_1 = full_model1$SSE ; SSE_2 = full_model2$SSE
SSE_F = SSE_1 + SSE_2 ; SSE_R = Reduced_model$SSE
df_F = n - 2*p - 2 ; df_R = n - p - 1 ; alpha = 0.05
F_0 = ((SSE_R - SSE_F)/(df_R - df_F)) / (SSE_F / df_F)
F_alpha = qf(alpha, df_R - df_F, df_F, lower.tail = FALSE)
F_0 ; F_alpha
SS_1_02 = ASS_calc(X2, y2, index_sol = c(1), index_given = c(0, 2), coef = TRUE)
SS_2_01 = ASS_calc(X2, y2, index_sol = c(2), index_given = c(0, 1), coef = TRUE)
beta2_hat = full_model2$beta_hat ; MSE2 = full_model2$MSE
X2tX2 = full_model2$XtX ; F_alpha = qf(0.1, p+1, n2 - p - 1, lower.tail = FALSE)
beta2_hat ; MSE2 ; X2tX2 ; F_alpha
beta2_null = c(0,2,1)
Tbeta2 = t(beta2_null - beta2_hat) %*% X2tX2 %*% (beta2_null - beta2_hat) - (p+1) * MSE2 * F_alpha
Tbeta2
R2_A = full_model1$SSR / full_model1$SST ; R2_B = full_model2$SSR / full_model2$SST
R2_A ; R2_B
x1 = c(1,2,3,1,2,3) ; x2 = c(-1,-1,-1,1,1,1) ; x3 = c(-1,0,1,1,0,-1)
y = c(7,8,10,15,18,26) ; X = cbind(x1,x2,x3) ; n = dim(X)[1] ; p = dim(X)[2] ; alpha = 0.05
source("functions/mult_reg.R")
one = c(rep(1,n)) ; X = cbind(one, X)
XtX_inv = solve(t(X) %*% X) ; Xty = t(X) %*% y ; yty = t(y) %*% y
beta_hat = XtX_inv %*% Xty
SSR = t(beta_hat) %*% Xty ; SSE = yty - t(beta_hat) %*% Xty ; SST = yty
df_SSR = p+1 ; df_SSE = n-p-1 ; df_total = n
MSR = SSR / df_SSR ; MSE = SSE / df_SSE
F_0 = MSR / MSE ; F_alpha = qf(alpha, df_SSR, df_SSE, lower.tail = FALSE)
anova_table = data.frame(
요인 = c("회귀", "잔차", "계"),
제곱합 = c(SSR, SSE, SST),
자유도 = c(df_SSR, df_SSE, df_total),
평균제곱합 = c(MSR, MSE, NA),
F_0 = c(F_0, NA, NA),
F_alpha = c(F_alpha, NA, NA)
)
beta_hat
print(anova_table)
x1 = c(1,2,3,1,2,3) ; x2 = c(-1,-1,-1,1,1,1) ; x3 = c(-1,0,1,1,0,-1)
y = c(7,8,10,15,18,26) ; X = cbind(x1,x2,x3) ; n = dim(X)[1] ; p = dim(X)[2] ; alpha = 0.05
SS_1_023 = ASS_calc(X = X, y = y, index_sol = c(1), index_given = c(0,2,3), coef = TRUE)
SS_1_02 = ASS_calc(X = X, y = y, index_sol = c(1), index_given = c(0,2), coef = TRUE)
x1 = c(1,2,3,4,5,6,7) ; x2 = c(-1,-1,-1,1,1,1,0) ; x3 = c(-1,0,1,-1,0,1,0)
y = c(7, 8, 10, 15, 18, 19, 14) ; X = cbind(x1,x2,x3) ; n = dim(X)[1] ; p = dim(X)[2]
standard_res = standard_calc(X, y)
x1 = c(1,2,3,4,5,6,7) ; x2 = c(-1,-1,-1,1,1,1,0) ; x3 = c(-1,0,1,-1,0,1,0)
y = c(7, 8, 10, 15, 18, 19, 14) ; X = cbind(x1,x2,x3) ; n = dim(X)[1] ; p = dim(X)[2]
standard_res = standard_calc(X, y)
Z = standard_res$Z ; ystar = standard_res$ystar ; xbar = standard_res$xbar ; ybar = standard_res$ybar
S_jj = standard_res$S_jj ; S_yy = standard_res$S_yy
alpha_hat = solve(t(Z) %*% Z) %*% t(Z) %*% ystar ; alpha_hat
corr_xx = t(Z) %*% Z ; corr_xx
corr_xy = t(Z) %*% ystar
x1 = c(1,2,3,4,5,6,7) ; x2 = c(-1,-1,-1,1,1,1,0) ; x3 = c(-1,0,1,-1,0,1,0)
y = c(7, 8, 10, 15, 18, 19, 14) ; X = cbind(x1,x2,x3) ; n = dim(X)[1] ; p = dim(X)[2]
standard_res = standard_calc(X, y)
Z = standard_res$Z ; ystar = standard_res$ystar ; xbar = standard_res$xbar ; ybar = standard_res$ybar
S_jj = standard_res$S_jj ; S_yy = standard_res$S_yy
alpha_hat = solve(t(Z) %*% Z) %*% t(Z) %*% ystar ; alpha_hat
corr_xx = t(Z) %*% Z ; corr_xx
corr_xy = t(Z) %*% ystar ; corr_xy
