round(critical_value, 3), "\n", sep = "")
}else{
cat("Since |t_0| <= t_", alpha/2, "(", df_SSEF, ")",
" there is not enough evidence to reject the null hypothesis.", "\n",
"Here, |t_0| = ", abs(round(t_0, 3)), " and t_", alpha/2, "(", df_SSEF, ") = ",
round(critical_value, 3), "\n", sep = "")
}
}
line1 <- data.frame(x = x1, y = y1)
line2 <- data.frame(x = x2, y = y2)
slope_test(line1, line2, alpha = 0.05)
slope_test = function(data1, data2, alpha){
n_1 = dim(data1)[1] ; n_2 = dim(data2)[1]
xbar_1 = mean(data1$x) ; ybar_1 = mean(data1$y)
S_xx_1 = sum((data1$x - xbar_1)^{2})
S_xy_1 = as.numeric(t(data1$x - xbar_1) %*% (data1$y - ybar_1))
beta1_1 = S_xy_1 / S_xx_1
beta0_1 = ybar_1 - beta1_1 * xbar_1
yhat_1 = beta0_1 + beta1_1 * data1$x
SSE_1 = sum((data1$y - yhat_1)^{2})
xbar_2 = mean(data2$x) ; ybar_2 = mean(data2$y)
S_xx_2 = sum((data2$x - xbar_2)^{2})
S_xy_2 = as.numeric(t(data2$x - xbar_2) %*% (data2$y - ybar_2))
beta1_2 = S_xy_2 / S_xx_2
beta0_2 = ybar_2 - beta1_2 * xbar_2
yhat_2 = beta0_2 + beta1_2 * data2$x
SSE_2 = sum((data2$y - yhat_2)^{2})
SSEF = SSE_1 + SSE_2
df_SSEF = (n_1 - 2) + (n_2 - 2)
MSEF = SSEF / df_SSEF
t_0 = (beta1_1 - beta1_2) / sqrt(MSEF * (1/S_xx_1 + 1/S_xx_2))
critical_value = qt(alpha/2, df = df_SSEF, lower.tail = FALSE)
if(abs(t_0) > critical_value){
cat("Since |t_0| > t_", alpha/2, "(", df_SSEF, ")",
" reject the null hypothesis.", "\n",
"Here, |t_0| = ", abs(round(t_0, 3)), " and t_", alpha/2, "(", df_SSEF, ") = ",
round(critical_value, 3), "\n", sep = "")
}else{
cat("Since |t_0| <= t_", alpha/2, "(", df_SSEF, ")",
" there is not enough evidence to reject the null hypothesis.", "\n",
"Here, |t_0| = ", abs(round(t_0, 3)), " and t_", alpha/2, "(", df_SSEF, ") = ",
round(critical_value, 3), "\n", sep = "")
}
}
line1 <- data.frame(x = x1, y = y1)
line2 <- data.frame(x = x2, y = y2)
slope_test(line1, line2, alpha = 0.05)
set.seed(1234)
n = 100 ; beta0 = 1 ; beta1 = 0.7
e = rnrorm(n, mean = 0, sd = sqrt(0.1))
set.seed(1234)
n = 100 ; beta0 = 1 ; beta1 = 0.7
e = rnorm(n, mean = 0, sd = sqrt(0.1))
x = runif(n, min = 0, max = 5)
y = exp(beta0 + beta1 * x + e)
mydata = data.frame(x = x, y = y)
plot(y ~ x, data = mydata)
SSE_lambda = function(x, y, lambda){
if (lambda == 0){
z_lambda = log(y) * prod(y)^{1/n}
}else{
z_lambda = (y^{lambda} - 1) / lambda * prod(y)^{(-1/n) * (lambda - 1)}
}
n = length(y)
X = matrix(c(rep(1, n), x), n, 2)
H = X %*% solve(t(X) %*% X) %*% t(X)
I = diag(1, n)
SSE_lambda = t(z_lambda) %*% (I - H) %*% z_lambda
return(SSE_lambda)
}
SSE_lambda = function(x, y, lambda){
if (lambda == 0){
z_lambda = log(y) * prod(y)^{1/n}
}else{
z_lambda = (y^{lambda} - 1) / lambda * prod(y)^{(-1/n) * (lambda - 1)}
}
n = length(y)
X = matrix(c(rep(1, n), x), n, 2)
H = X %*% solve(t(X) %*% X) %*% t(X)
I = diag(1, n)
SSE_lambda = t(z_lambda) %*% (I - H) %*% z_lambda
return(SSE_lambda)
}
vec_SSE_lambda <- Vectorize(SSE_lambda, "lambda")
lambda <- seq(-2, 2, 0.2)
all_SSE <- vec_SSE_lambda(mydata$x, mydata$y, lambda)
(best_lambda <- lambda[which.min(all_SSE)])
(min_SSE <- all_SSE[which.min(all_SSE)])
plot(lambda, log(all_SSE),
type = "b", lwd = 2,
xlab = "Lambda", ylab = "Sum of Squared Error(log-scale)")
points(x = best_lambda, y = log(min_SSE),
col = "red", cex = 2, pch = 8)
set.seed(1234)
n = 10000 ; beta0 = 1 ; beta1 = 4
e = rnorm(n, mean = 0, sd = sqrt(0.1))
x = runif(n, min = 0, max = 5)
y = exp(beta0 + beta1 * (1/x) + e)
mydata = data.frame(x = x, y = y)
plot(y ~ x, data = mydata)
set.seed(1234)
n = 10000 ; beta0 = 1 ; beta1 = 4
e = rnorm(n, mean = 0, sd = sqrt(0.1))
x = runif(n, min = 0, max = 5)
1/y = exp(beta0 + beta1 * (1/x) + e)
set.seed(1234)
n = 10000 ; beta0 = 1 ; beta1 = 4
e = rnorm(n, mean = 0, sd = sqrt(0.1))
x = runif(n, min = 0, max = 5)
y = 1 / (1 + exp(beta0 + beta1 * x + e))
mydata = data.frame(x = x, y = y)
plot(y ~ x, data = mydata)
set.seed(1234)
n = 100 ; beta0 = 1 ; beta1 = 0.7
e = rnorm(n, mean = 0, sd = sqrt(0.1))
x = runif(n, min = 0, max = 5)
y = exp(beta0 + beta1 * x + e)
mydata = data.frame(x = x, y = y)
plot(y ~ x, data = mydata)
SSE_lambda = function(x, y, lambda){
if (lambda == 0){
z_lambda = log(y) * prod(y)^{1/n}
}else{
z_lambda = (y^{lambda} - 1) / lambda * prod(y)^{(-1/n) * (lambda - 1)}
}
n = length(y)
X = matrix(c(rep(1, n), x), n, 2)
H = X %*% solve(t(X) %*% X) %*% t(X)
I = diag(1, n)
SSE_lambda = t(z_lambda) %*% (I - H) %*% z_lambda
return(SSE_lambda)
}
vec_SSE_lambda <- Vectorize(SSE_lambda, "lambda")
lambda <- seq(-2, 2, 0.2)
all_SSE <- vec_SSE_lambda(mydata$x, mydata$y, lambda)
(best_lambda <- lambda[which.min(all_SSE)])
(min_SSE <- all_SSE[which.min(all_SSE)])
plot(lambda, log(all_SSE),
type = "b", lwd = 2,
xlab = "Lambda", ylab = "Sum of Squared Error(log-scale)")
points(x = best_lambda, y = log(min_SSE),
col = "red", cex = 2, pch = 8)
set.seed(1234)
n = 10000 ; beta0_big = 1 ; beta1_big = 4
e_big = rnorm(n, mean = 0, sd = sqrt(0.1))
x_big = runif(n, min = 0, max = 5)
y_big = 1 / (1 + exp(beta0_big + beta1_big * x_big + e_big))
mydata_big = data.frame(x = x_big, y = y_big)
plot(y_big ~ x_big, data = mydata_big)
lambda_big <- seq(-5, 5, 0.1)
all_SSE_big <- vec_SSE_lambda(mydata_big$x_big, mydata_big$y_big, lambda_big)
set.seed(1234)
n = 10000 ; beta0_big = 1 ; beta1_big = 4
e_big = rnorm(n, mean = 0, sd = sqrt(0.1))
x_big = runif(n, min = 0, max = 100)
y_big = 1 / (1 + exp(beta0_big + beta1_big * x_big + e_big))
mydata_big = data.frame(x = x_big, y = y_big)
plot(y_big ~ x_big, data = mydata_big)
set.seed(1234)
n = 10000 ; beta0_big = 1 ; beta1_big = 4
e_big = rnorm(n, mean = 0, sd = sqrt(0.1))
x_big = runif(n, min = 0, max = 10)
y_big = 1 / (1 + exp(beta0_big + beta1_big * x_big + e_big))
mydata_big = data.frame(x = x_big, y = y_big)
plot(y_big ~ x_big, data = mydata_big)
lambda_big <- seq(-5, 5, 0.1)
all_SSE_big <- vec_SSE_lambda(mydata_big$x_big, mydata_big$y_big, lambda_big)
e-10
1 * e-10
e-1
SSE_lambda_big = function(x, y, lambda){
if (lambda == 0){
z_lambda = log(y) * prod(y)^{1/n}
}else{
z_lambda = (y^{lambda} - 1) / lambda * prod(y)^{(-1/n) * (lambda - 1)}
}
n = length(y)
X = matrix(c(rep(1, n), x), n, 2)
H = X %*% solve(t(X) %*% X + diag(10^{-8}, 2)) %*% t(X)
I = diag(1, n)
SSE_lambda = t(z_lambda) %*% (I - H) %*% z_lambda
return(SSE_lambda)
}
vec_SSE_lambda_big <- Vectorize(SSE_lambda_big, "lambda")
lambda_big <- seq(-5, 5, 0.1)
all_SSE_big <- vec_SSE_lambda_big(mydata_big$x_big, mydata_big$y_big, lambda_big)
set.seed(1234)
n = 10000 ; beta0_big = 1 ; beta1_big = 4
e_big = rnorm(n, mean = 0, sd = sqrt(0.1))
x_big = runif(n, min = 0, max = 10)
y_big = 1 / (1 + exp(beta0_big + beta1_big * x_big + e_big))
mydata_big = data.frame(x = x_big, y = y_big)
plot(y_big ~ x_big, data = mydata_big)
SSE_lambda_big = function(x, y, lambda){
if (lambda == 0){
z_lambda = log(y) * prod(y)^{1/n}
}else{
z_lambda = (y^{lambda} - 1) / lambda * prod(y)^{(-1/n) * (lambda - 1)}
}
n = length(y)
X = matrix(c(rep(1, n), x), n, 2)
H = X %*% solve(t(X) %*% X + diag(10^{-8}, 2)) %*% t(X)
I = diag(1, n)
SSE_lambda = t(z_lambda) %*% (I - H) %*% z_lambda
return(SSE_lambda)
}
vec_SSE_lambda_big <- Vectorize(SSE_lambda_big, "lambda")
lambda_big <- seq(-5, 5, 0.1)
all_SSE_big <- vec_SSE_lambda_big(mydata_big$x_big, mydata_big$y_big, lambda_big)
set.seed(1234)
n = 10000 ; beta0_big = 1 ; beta1_big = 4
e_big = rnorm(n, mean = 0, sd = sqrt(0.1))
x_big = runif(n, min = 0, max = 10)
eps_big = runif(n, min = 1, max = 10) * 10^{-6}
y_big = 1 / (1 + exp(beta0_big + beta1_big * x_big + e_big)) + eps_big
mydata_big = data.frame(x = x_big, y = y_big)
plot(y_big ~ x_big, data = mydata_big)
SSE_lambda_big = function(x, y, lambda){
if (lambda == 0){
z_lambda = log(y) * prod(y)^{1/n}
}else{
z_lambda = (y^{lambda} - 1) / lambda * prod(y)^{(-1/n) * (lambda - 1)}
}
n = length(y)
X = matrix(c(rep(1, n), x), n, 2)
H = X %*% solve(t(X) %*% X + diag(10^{-8}, 2)) %*% t(X)
I = diag(1, n)
SSE_lambda = t(z_lambda) %*% (I - H) %*% z_lambda
return(SSE_lambda)
}
vec_SSE_lambda_big <- Vectorize(SSE_lambda_big, "lambda")
lambda_big <- seq(-5, 5, 0.1)
all_SSE_big <- vec_SSE_lambda_big(mydata_big$x_big, mydata_big$y_big, lambda_big)
set.seed(1234)
n = 10000 ; beta0_big = 1 ; beta1_big = 4
e_big = rnorm(n, mean = 0, sd = sqrt(0.1))
x_big = runif(n, min = 0, max = 10)
y_big = 1 / (1 + exp(beta0_big + beta1_big * x_big + e_big))
mydata_big = data.frame(x = x_big, y = y_big)
plot(y_big ~ x_big, data = mydata_big)
SSE_lambda_big = function(x, y, lambda){
if (lambda == 0){
z_lambda = log(y) * prod(y)^(1/n)
}else{
z_lambda = (y^{lambda} - 1) / lambda * prod(y)^{(-1/n) * (lambda - 1)}
}
n = length(y)
X = matrix(c(rep(1, n), x), n, 2)
H = X %*% solve(t(X) %*% X + diag(10^{-8}, 2)) %*% t(X)
I = diag(1, n)
SSE_lambda = t(z_lambda) %*% (I - H) %*% z_lambda
return(SSE_lambda)
}
vec_SSE_lambda_big <- Vectorize(SSE_lambda_big, "lambda")
lambda_big <- seq(-5, 5, 0.1)
all_SSE_big <- vec_SSE_lambda_big(mydata_big$x, mydata_big$y, lambda_big)
(best_lambda_big <- lambda_big[which.min(all_SSE_big)])
(min_SSE_big <- all_SSE_big[which.min(all_SSE_big)])
plot(lambda_big, log(all_SSE_big),
type = "b", lwd = 2,
xlab = "Lambda", ylab = "Sum of Squared Error(log-scale)")
points(x = best_lambda_big, y = log(1 / min_SSE_big - 1),
col = "red", cex = 2, pch = 8)
x = c(6.4,16.1,42.1,2.1,30.7,32.1,7.2,3.4,20.8,1.5)
y = c(1.7,2.7,4.9,0.3,3.9,4.1,1.2,0.5,3.3,0.2)
plot(x, y, xlab = "구매 상품의 금액 x (단위 : 천원)", ylab = "소요되는 시간 y (단위 : 분)",
main = "슈퍼마켓 데이터", pch = 19, cex = 0.4)
x = c(6.4,16.1,42.1,2.1,30.7,32.1,7.2,3.4,20.8,1.5)
y = c(1.7,2.7,4.9,0.3,3.9,4.1,1.2,0.5,3.3,0.2)
plot(x, y, xlab = "구매 상품의 금액 x (단위 : 천원)", ylab = "소요되는 시간 y (단위 : 분)",
main = "슈퍼마켓 데이터", pch = 19, cex = 0.4)
S_xx = sum((x-mean(x))^{2}) ; S_xy = sum((x-mean(x)*(y-mean(y)) )) ; S_yy = sum((y-mean(y))^{2})
S_xx = sum((x-mean(x))^{2}) ; S_xy = sum((x-mean(x)*(y-mean(y)) )) ; S_yy = sum((y-mean(y))^{2})
beta1_hat = S_xy / S_xx ; beta0_hat = mean(y) - beta1_hat * mean(x)
y_hat = beta0_hat + beta1_hat * x
SST = S_yy ; SSE = sum((y-y_hat)^{2}) ; SSR = SST - SSE
r_squared = SSR/SST ; r_squared
S_xx = sum((x-mean(x))^{2}) ; S_xy = sum( (x-mean(x))*(y-mean(y)) ) ; S_yy = sum((y-mean(y))^{2})
beta1_hat = S_xy / S_xx ; beta0_hat = mean(y) - beta1_hat * mean(x)
y_hat = beta0_hat + beta1_hat * x
SST = S_yy ; SSE = sum((y-y_hat)^{2}) ; SSR = SST - SSE
r_squared = SSR/SST ; r_squared
r_sq_calc = function(x, y){
xbar = mean(x) ; ybar = mean(y)
S_xx = sum((x-xbar)^{2}) ; S_xy = sum((x-xbar)*(y-ybar) ) ; S_yy = sum((y-ybar)^{2})
beta1_hat = S_xy / S_xx ; beta0_hat = mean(y) - beta1_hat * mean(x)
y_hat = beta0_hat + beta1_hat * x
SST = S_yy ; SSE = sum((y-y_hat)^{2}) ; SSR = SST - SSE
r_squared = SSR/SST ; r_squared
}
S_xx = sum((x-mean(x))^{2}) ; S_xy = sum( (x-mean(x))*(y-mean(y)) ) ; S_yy = sum((y-mean(y))^{2})
beta1_hat = S_xy / S_xx ; beta0_hat = mean(y) - beta1_hat * mean(x)
y_hat = beta0_hat + beta1_hat * x
SST = S_yy ; SSE = sum((y-y_hat)^{2}) ; SSR = SST - SSE
## (2)
r_squared = SSR/SST ; r_squared
r_sq_calc = function(x, y){
xbar = mean(x) ; ybar = mean(y)
S_xx = sum((x-xbar)^{2}) ; S_xy = sum((x-xbar)*(y-ybar) ) ; S_yy = sum((y-ybar)^{2})
beta1_hat = S_xy / S_xx ; beta0_hat = ybar - beta1_hat * xbar
y_hat = beta0_hat + beta1_hat * x
SST = S_yy ; SSE = sum((y-y_hat)^{2}) ; SSR = SST - SSE
r_squared = SSR/SST ; r_squared
return(r_squared)
}
## (3)
y_a = log(y) ; r_sq_a = r_sq_calc(x, y_a)
x_b = sqrt(x) ; r_sq_b = r_sq_calc(x_b, y)
x_c = log(x, base = 10) ; y_c = log(y, base = 10) ; r_sq_c = r_sq_calc(x_c, y_c)
y_d = log(y, base = 10) ; r_sq_d = r_sq_calc(x, y_d)
x_e = 1/x ; r_sq_e = r_sq_calc(x_e, y)
print(glue("(a) r squared = {r_sq_a}, (b) r squared = {r_sq_b}, (c) r squared = {r_sq_c},
(d) r squared = {r_sq_d}, (e) r squared = {r_sq_e}"))
S_xx = sum((x-mean(x))^{2}) ; S_xy = sum( (x-mean(x))*(y-mean(y)) ) ; S_yy = sum((y-mean(y))^{2})
beta1_hat = S_xy / S_xx ; beta0_hat = mean(y) - beta1_hat * mean(x)
y_hat = beta0_hat + beta1_hat * x
SST = S_yy ; SSE = sum((y-y_hat)^{2}) ; SSR = SST - SSE
## (2)
r_squared = SSR/SST ; r_squared
r_sq_calc = function(x, y){
xbar = mean(x) ; ybar = mean(y)
S_xx = sum((x-xbar)^{2}) ; S_xy = sum((x-xbar)*(y-ybar) ) ; S_yy = sum((y-ybar)^{2})
beta1_hat = S_xy / S_xx ; beta0_hat = ybar - beta1_hat * xbar
y_hat = beta0_hat + beta1_hat * x
SST = S_yy ; SSE = sum((y-y_hat)^{2}) ; SSR = SST - SSE
r_squared = SSR/SST ; r_squared
return(list(r_squared = r_squared, beta1_hat = beta1_hat, beta0_hat = beta0_hat))
}
## (3)
y_a = log(y) ; result_a = r_sq_calc(x, y_a) ; r_sq_a = result_a$r_squared
x_b = sqrt(x) ; result_b = r_sq_calc(x_b, y) ; r_sq_b = result_b$r_squared
x_c = log(x, base = 10) ; y_c = log(y, base = 10) ; result_c = r_sq_calc(x_c, y_c) ; r_sq_c = result_c$r_squared
y_d = log(y, base = 10) ; result_d = r_sq_calc(x, y_d) ; r_sq_d = result_d$r_squared
x_e = 1/x ; result_e = r_sq_calc(x_e, y) ; r_sq_e = result_e$r_squared
print(glue("(a) r squared = {r_sq_a}, (b) r squared = {r_sq_b}, (c) r squared = {r_sq_c},
(d) r squared = {r_sq_d}, (e) r squared = {r_sq_e}"))
## (4)
# beta0_hat = result
S_xx = sum((x-mean(x))^{2}) ; S_xy = sum( (x-mean(x))*(y-mean(y)) ) ; S_yy = sum((y-mean(y))^{2})
beta1_hat = S_xy / S_xx ; beta0_hat = mean(y) - beta1_hat * mean(x)
y_hat = beta0_hat + beta1_hat * x
SST = S_yy ; SSE = sum((y-y_hat)^{2}) ; SSR = SST - SSE
## (2)
r_squared = SSR/SST ; r_squared
r_sq_calc = function(x, y){
xbar = mean(x) ; ybar = mean(y)
S_xx = sum((x-xbar)^{2}) ; S_xy = sum((x-xbar)*(y-ybar) ) ; S_yy = sum((y-ybar)^{2})
beta1_hat = S_xy / S_xx ; beta0_hat = ybar - beta1_hat * xbar
y_hat = beta0_hat + beta1_hat * x
SST = S_yy ; SSE = sum((y-y_hat)^{2}) ; SSR = SST - SSE
r_squared = SSR/SST ; r_squared
return(list(r_squared = r_squared, beta1_hat = beta1_hat, beta0_hat = beta0_hat))
}
## (3)
y_a = log(y) ; result_a = r_sq_calc(x, y_a) ; r_sq_a = result_a$r_squared
x_b = sqrt(x) ; result_b = r_sq_calc(x_b, y) ; r_sq_b = result_b$r_squared
x_c = log(x, base = 10) ; y_c = log(y, base = 10) ; result_c = r_sq_calc(x_c, y_c) ; r_sq_c = result_c$r_squared
y_d = log(y, base = 10) ; result_d = r_sq_calc(x, y_d) ; r_sq_d = result_d$r_squared
x_e = 1/x ; result_e = r_sq_calc(x_e, y) ; r_sq_e = result_e$r_squared
print(glue("(a) r squared = {r_sq_a}, (b) r squared = {r_sq_b}, (c) r squared = {r_sq_c},
(d) r squared = {r_sq_d}, (e) r squared = {r_sq_e}"))
## (4)
beta0_hat = result_b$beta0_hat ; beta1_hat = result_b$beta1_hat
y_hat_10000 = beta0_hat + beta1_hat * 10000 ; y_hat_10000
S_xx = sum((x-mean(x))^{2}) ; S_xy = sum( (x-mean(x))*(y-mean(y)) ) ; S_yy = sum((y-mean(y))^{2})
beta1_hat = S_xy / S_xx ; beta0_hat = mean(y) - beta1_hat * mean(x)
y_hat = beta0_hat + beta1_hat * x
SST = S_yy ; SSE = sum((y-y_hat)^{2}) ; SSR = SST - SSE
## (2)
r_squared = SSR/SST ; r_squared
r_sq_calc = function(x, y){
xbar = mean(x) ; ybar = mean(y)
S_xx = sum((x-xbar)^{2}) ; S_xy = sum((x-xbar)*(y-ybar) ) ; S_yy = sum((y-ybar)^{2})
beta1_hat = S_xy / S_xx ; beta0_hat = ybar - beta1_hat * xbar
y_hat = beta0_hat + beta1_hat * x
SST = S_yy ; SSE = sum((y-y_hat)^{2}) ; SSR = SST - SSE
r_squared = SSR/SST ; r_squared
return(list(r_squared = r_squared, beta1_hat = beta1_hat, beta0_hat = beta0_hat))
}
## (3)
y_a = log(y) ; result_a = r_sq_calc(x, y_a) ; r_sq_a = result_a$r_squared
x_b = sqrt(x) ; result_b = r_sq_calc(x_b, y) ; r_sq_b = result_b$r_squared
x_c = log(x, base = 10) ; y_c = log(y, base = 10) ; result_c = r_sq_calc(x_c, y_c) ; r_sq_c = result_c$r_squared
y_d = log(y, base = 10) ; result_d = r_sq_calc(x, y_d) ; r_sq_d = result_d$r_squared
x_e = 1/x ; result_e = r_sq_calc(x_e, y) ; r_sq_e = result_e$r_squared
print(glue("(a) r squared = {r_sq_a}, (b) r squared = {r_sq_b}, (c) r squared = {r_sq_c},
(d) r squared = {r_sq_d}, (e) r squared = {r_sq_e}"))
## (4)
beta0_hat = result_b$beta0_hat ; beta1_hat = result_b$beta1_hat
y_hat_10 = beta0_hat + beta1_hat * 10 ; y_hat_10
S_xx = sum((x-mean(x))^{2}) ; S_xy = sum( (x-mean(x))*(y-mean(y)) ) ; S_yy = sum((y-mean(y))^{2})
beta1_hat = S_xy / S_xx ; beta0_hat = mean(y) - beta1_hat * mean(x)
y_hat = beta0_hat + beta1_hat * x
SST = S_yy ; SSE = sum((y-y_hat)^{2}) ; SSR = SST - SSE
## (2)
r_squared = SSR/SST ; r_squared
r_sq_calc = function(x, y){
xbar = mean(x) ; ybar = mean(y)
S_xx = sum((x-xbar)^{2}) ; S_xy = sum((x-xbar)*(y-ybar) ) ; S_yy = sum((y-ybar)^{2})
beta1_hat = S_xy / S_xx ; beta0_hat = ybar - beta1_hat * xbar
y_hat = beta0_hat + beta1_hat * x
SST = S_yy ; SSE = sum((y-y_hat)^{2}) ; SSR = SST - SSE
r_squared = SSR/SST ; r_squared
return(list(r_squared = r_squared, beta1_hat = beta1_hat, beta0_hat = beta0_hat))
}
## (3)
y_a = log(y) ; result_a = r_sq_calc(x, y_a) ; r_sq_a = result_a$r_squared
x_b = sqrt(x) ; result_b = r_sq_calc(x_b, y) ; r_sq_b = result_b$r_squared
x_c = log(x, base = 10) ; y_c = log(y, base = 10) ; result_c = r_sq_calc(x_c, y_c) ; r_sq_c = result_c$r_squared
y_d = log(y, base = 10) ; result_d = r_sq_calc(x, y_d) ; r_sq_d = result_d$r_squared
x_e = 1/x ; result_e = r_sq_calc(x_e, y) ; r_sq_e = result_e$r_squared
print(glue("(a) r squared = {r_sq_a}, (b) r squared = {r_sq_b}, (c) r squared = {r_sq_c},
(d) r squared = {r_sq_d}, (e) r squared = {r_sq_e}"))
## (4)
beta0_hat = result_b$beta0_hat ; beta1_hat = result_b$beta1_hat
y_hat_10 = beta0_hat + beta1_hat * sqrt(10) ; y_hat_10
set.seed(1234)
n = 1000 ; beta0_big = 1 ; beta1_big = 4
e_big = rnorm(n, mean = 0, sd = sqrt(0.1))
x_big = runif(n, min = 0, max = 10)
y_big = 1 / (1 + exp(beta0_big + beta1_big * x_big + e_big))
mydata_big = data.frame(x = x_big, y = y_big)
plot(y_big ~ x_big, data = mydata_big)
SSE_lambda_big = function(x, y, lambda){
if (lambda == 0){
z_lambda = log(y) * prod(y)^(1/n)
}else{
z_lambda = (y^{lambda} - 1) / lambda * prod(y)^{(-1/n) * (lambda - 1)}
}
n = length(y)
X = matrix(c(rep(1, n), x), n, 2)
H = X %*% solve(t(X) %*% X ) %*% t(X)
I = diag(1, n)
SSE_lambda = t(z_lambda) %*% (I - H) %*% z_lambda
return(SSE_lambda)
}
vec_SSE_lambda_big <- Vectorize(SSE_lambda_big, "lambda")
lambda_big <- seq(-3, 3, 0.2)
all_SSE_big <- vec_SSE_lambda_big(mydata_big$x, mydata_big$y, lambda_big)
(best_lambda_big <- lambda_big[which.min(all_SSE_big)])
(min_SSE_big <- all_SSE_big[which.min(all_SSE_big)])
plot(lambda_big, log(all_SSE_big),
type = "b", lwd = 2,
xlab = "Lambda", ylab = "Sum of Squared Error(log-scale)")
points(x = best_lambda_big, y = log(1 / min_SSE_big - 1),
col = "red", cex = 2, pch = 8)
set.seed(1234)
n = 1000 ; beta0_big = 1 ; beta1_big = 4
e_big = rnorm(n, mean = 0, sd = sqrt(0.1))
x_big = runif(n, min = 0, max = 10)
# y_big = 1 / (1 + exp(beta0_big + beta1_big * x_big + e_big))
y_big = beta0_big + beta1_big * (1/x_big) + e_big
mydata_big = data.frame(x = x_big, y = y_big)
plot(y_big ~ x_big, data = mydata_big)
SSE_lambda_big = function(x, y, lambda){
if (lambda == 0){
z_lambda = log(y) * prod(y)^(1/n)
}else{
z_lambda = (y^{lambda} - 1) / lambda * prod(y)^{(-1/n) * (lambda - 1)}
}
n = length(y)
X = matrix(c(rep(1, n), x), n, 2)
H = X %*% solve(t(X) %*% X ) %*% t(X)
I = diag(1, n)
SSE_lambda = t(z_lambda) %*% (I - H) %*% z_lambda
return(SSE_lambda)
}
vec_SSE_lambda_big <- Vectorize(SSE_lambda_big, "lambda")
lambda_big <- seq(-3, 3, 0.2)
all_SSE_big <- vec_SSE_lambda_big(mydata_big$x, mydata_big$y, lambda_big)
(best_lambda_big <- lambda_big[which.min(all_SSE_big)])
(min_SSE_big <- all_SSE_big[which.min(all_SSE_big)])
plot(lambda_big, log(all_SSE_big),
type = "b", lwd = 2,
xlab = "Lambda", ylab = "Sum of Squared Error(log-scale)")
points(x = best_lambda_big, y = log(1 / min_SSE_big - 1),
col = "red", cex = 2, pch = 8)
plot(lambda_big, log(all_SSE_big),
type = "b", lwd = 2,
xlab = "Lambda", ylab = "Sum of Squared Error(log-scale)")
points(x = best_lambda_big, y = log(1 / min_SSE_big - 1),
col = "red", cex = 2, pch = 8)
plot(lambda_big, log(all_SSE_big),
type = "b", lwd = 2, xlim = c(0.5, 1.5),
xlab = "Lambda", ylab = "Sum of Squared Error(log-scale)")
points(x = best_lambda_big, y = log(1 / min_SSE_big - 1),
col = "red", cex = 2, pch = 8)
plot(lambda_big, log(all_SSE_big),
type = "b", lwd = 2, xlim = c(0.9, 1.3),
xlab = "Lambda", ylab = "Sum of Squared Error(log-scale)")
points(x = best_lambda_big, y = log(1 / min_SSE_big - 1),
col = "red", cex = 2, pch = 8)
plot(lambda_big, log(all_SSE_big),
type = "b", lwd = 2,
xlab = "Lambda", ylab = "Sum of Squared Error(log-scale)")
points(x = best_lambda_big, y = log(1 / min_SSE_big - 1),
col = "red", cex = 3, pch = 19)
plot(lambda_big, log(all_SSE_big),
type = "b", lwd = 2,
xlab = "Lambda", ylab = "Sum of Squared Error(log-scale)")
points(x = 1/best_lambda_big, y = min_SSE_big,
col = "red", cex = 3, pch = 19)
plot(lambda_big, log(all_SSE_big),
type = "b", lwd = 2,
xlab = "Lambda", ylab = "Sum of Squared Error(log-scale)")
points(x = best_lambda_big, y = min_SSE_big,
col = "red", cex = 3, pch = 19)
plot(lambda_big, log(all_SSE_big),
type = "b", lwd = 2,
xlab = "Lambda", ylab = "Sum of Squared Error(log-scale)")
points(x = best_lambda_big, y = log(min_SSE_big),
col = "red", cex = 3, pch = 19)
