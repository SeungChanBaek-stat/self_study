for (i in 1:(A_num)){
for (j in 1:B_num){
mu_AB[j,i] = alpha_beta_hat[j,i] + alpha_hat[i] + mu_hat
}
}
mu_AB = round(mu_AB, 2)
print(mu_AB)
y = c(12, 18, 14, 12, 13, 19, 17, 21, 24, 30) ; A_num = 4 ; repeat_vec = c(2, 3, 3, 2)
res = oneway_anova(y, A_num = A_num, repeat_vec = repeat_vec, method = "one", alpha = 0.05)
res$alpha_hat
res$X
y = c(12, 18, 14, 12, 13, 19, 17, 21, 24, 30) ; A_num = 4 ; repeat_vec = c(2, 3, 3, 2)
res = oneway_anova(y, A_num = A_num, repeat_vec = repeat_vec, method = "two", alpha = 0.05)
res$gamma_hat
res$X
y = c(1.7, 2.2, 3.1, 4.3, 2.5, 1.5)
## 정규방정식을 활용한 기존 방법
twoway_test = twoway_anova(y = y, A_num = 2, B_num = 3, R_num = 1, alpha = 0.05)
twoway_test$X
twoway_test$params$mu_hat
twoway_test$params$alpha_hat
twoway_test$params$beta_hat
## 방법 1 : 모형에 가정을 직접 대입하는 방식
twoway_test_one = twoway_anova(y = y, A_num = 2, B_num = 3, R_num = 1, method = "one", alpha = 0.05)
twoway_test_one$X
twoway_test_one$params$mu_hat
twoway_test_one$params$alpha_hat
twoway_test_one$params$beta_hat
## 방법 2: 변수 1개를 제거하는 방식
twoway_test_two = twoway_anova(y = y, A_num = 2, B_num = 3, R_num = 1, method = "two", alpha = 0.05)
twoway_test_two$X
twoway_test_two$params$gamma_0_hat
twoway_test_two$params$gamma_hat
twoway_test_two$params$tau_hat
y = c(2.5, 3.3, 2.6, 3.2, 1.9, 2.1,
2.6, 3.0, 2.5, 3.1, 2.0, 2.3,
2.9, 3.2, 3.1, 2.8, 2.7, 3.2,
3.0, 3.4, 2.9, 3.5, 4.2, 4.0)
## 정규방정식을 활용한 기존 방법
twoway_anova_test = twoway_anova(y, A_num = 4, B_num = 3, R_num = 2, alpha = 0.05)
twoway_anova_test$params$mu_hat
twoway_anova_test$params$alpha_hat
twoway_anova_test$params$beta_hat
twoway_anova_test$params$alpha_beta_hat
## 방법 1 : 모형에 가정을 직접 대입하는 방식
twoway_anova_test_one = twoway_anova(y, A_num = 4, B_num = 3, R_num = 2, method = "one", alpha = 0.05)
twoway_anova_test_one$params$mu_hat
twoway_anova_test_one$params$alpha_hat
twoway_anova_test_one$params$beta_hat
twoway_anova_test_one$params$alpha_beta_hat
## 방법 2: 변수 1개를 제거하는 방식
twoway_anova_test_two = twoway_anova(y = y, A_num = 4, B_num = 3, R_num = 2, method = "two", alpha = 0.05)
twoway_anova_test_two$X
twoway_anova_test_two$params$gamma_0_hat
twoway_anova_test_two$params$gamma_hat
twoway_anova_test_two$params$tau_hat
twoway_anova_test_two$params$gamma_tau_hat
group <- factor(c(rep("A", 5), rep("B", 5), rep("C", 5)))
y <- c(210, 240, 270, 270, 300, 210, 240, 240, 270, 270, 180, 210, 210, 210, 240)
aov.fit <- aov(y ~ group)
summary(aov.fit)
aov.fit$coefficients
lm.fit <- lm(y ~ group)
summary(lm.fit)
dummy.coef(aov.fit)
oneway_res = oneway_anova(y, A_num = 3, repeat_vec = c(5,5,5), alpha = 0.05)
oneway_res$alpha_hat
contrasts(group)
X <- model.matrix(~group) ; X
contrasts(group) <- contr.sum
contrasts(group)
aov.fit <- aov(y ~ group)
summary(aov.fit)
aov.fit$coefficient
dummy.coef(aov.fit)
oneway_res_one = oneway_anova(y, A_num = 3, repeat_vec = c(5,5,5), method = "one", alpha = 0.05)
oneway_res_one$alpha_hat
diet <- factor(c(1,1,2,2,2,3,3,3,4,4))
loss <- c(12, 18, 14, 12, 13, 19, 17, 21, 24, 30)
summary(aov(loss ~ diet))
fit <- lm(loss ~ diet)
anova(fit)
summary(fit)
y <- c(90.1, 90.0, 89.5, 89.8, 90.5, 90.8, 91.6, 91.4, 91.1, 91.3, 90.0, 90.6)
oneway_res = oneway_anova(y, A_num = 4, repeat_vec = c(3,3,3,3), method ="one", alpha = 0.05)
oneway_res$alpha_hat
y <- c(1.02, 0.86, 1.00, 1.22, 1.33, 1.10,
1.28, 1.72, 1.60, 1.60,
0.94, 0.86, 0.90, 1.26, 1.04)
oneway_res = oneway_anova(y, A_num = 3, repeat_vec = c(6,4,5), alpha = 0.05)
oneway_res_one = oneway_anova(y, A_num = 3, repeat_vec = c(6,4,5), method = "one", alpha = 0.05)
oneway_res_two = oneway_anova(y, A_num = 3, repeat_vec = c(6,4,5), method = "two", alpha = 0.05)
X = oneway_res$X ; X
t(X) %*% X ; t(X) %*% y
oneway_res$alpha_hat
oneway_res_one$alpha_hat
oneway_res$anova_table
oneway_res_one$anova_table
oneway_res_two$anova_table
y = c(5.2, 4.4, 4.3, 4.9,
5.0, 5.3, 5.1, 4.7,
5.5, 5.8, 4.8, 4.9,
6.9, 6.6, 6.6, 7.3,
8.3, 8.4, 8.5, 7.9)
twoway_res = twoway_anova(y, A_num = 5, B_num = 4, R_num = 1, alpha = 0.05)
A_num = 5 ; B_num = 4
mu_AB = matrix(0, nrow = B_num, ncol = A_num)
mu_hat = twoway_res$params$mu_hat
alpha_hat = twoway_res$params$alpha_hat
beta_hat = twoway_res$params$beta_hat
for (i in 1:(A_num)){
for (j in 1:B_num){
mu_AB[j,i] = beta_hat[j] + alpha_hat[i] + mu_hat
}
}
mu_AB = round(mu_AB, 2)
print(mu_AB)
twoway_res_one = twoway_anova(y, A_num = 5, B_num = 4, R_num = 1, method = "one", alpha = 0.05)
twoway_res_one$anova_table
y = c(2.5, 3.3, 2.6, 3.2, 1.9, 2.1,
2.6, 3.0, 2.5, 3.1, 2.0, 2.3,
2.9, 3.2, 3.1, 2.8, 2.7, 3.2,
3.0, 3.4, 2.9, 3.5, 4.2, 4.0)
twoway_anova_test = twoway_anova(y, A_num = 4, B_num = 3, R_num = 2, alpha = 0.05)
test_vec = c(2,3,5)
n = 2 * 3 * 5
one = c(rep(1, n))
w_1 = c(rep(-3/2, 2),rep(1,3),rep(0,5))
w_2 = c(rep(-5/2, 2),rep(0,3),rep(1,5))
X = cbind(one, w_1, w_2)
X
test_vec = c(2,3,5)
n = sum(test_vec)
one = c(rep(1, n))
w_1 = c(rep(-3/2, 2),rep(1,3),rep(0,5))
w_2 = c(rep(-5/2, 2),rep(0,3),rep(1,5))
X = cbind(one, w_1, w_2)
X
XtX = t(X) %*% X ; XtX
solve(XtX)
1/6
7/30
knitr::opts_chunk$set(echo = TRUE)
source("functions/mult_reg.R", echo = F)
source("functions/reg_diagnostics.R", echo = F)
source("functions/var_selection.R", echo = F)
source("functions/anova_reg.R", echo = F)
y = c(12, 18, 14, 12, 13, 19, 17, 21, 24, 30) ; A_num = 4 ; repeat_vec = c(2, 3, 3, 2)
res = oneway_anova(y, A_num = A_num, repeat_vec = repeat_vec, alpha = 0.05)
res$X
res$alpha_hat
y = c(2.5, 3.3, 2.6, 3.2, 1.9, 2.1,
2.6, 3.0, 2.5, 3.1, 2.0, 2.3,
2.9, 3.2, 3.1, 2.8, 2.7, 3.2,
3.0, 3.4, 2.9, 3.5, 4.2, 4.0)
twoway_anova_test = twoway_anova(y, A_num = 4, B_num = 3, R_num = 2, alpha = 0.05)
A_num = 4 ; B_num = 3
mu_AB = matrix(0, nrow = B_num, ncol = A_num)
mu_hat = twoway_anova_test$params$mu_hat
alpha_hat = twoway_anova_test$params$alpha_hat
alpha_beta_hat = twoway_anova_test$params$alpha_beta_hat
for (i in 1:(A_num)){
for (j in 1:B_num){
mu_AB[j,i] = alpha_beta_hat[j,i] + alpha_hat[i] + mu_hat
}
}
mu_AB = round(mu_AB, 2)
print(mu_AB)
y = c(12, 18, 14, 12, 13, 19, 17, 21, 24, 30) ; A_num = 4 ; repeat_vec = c(2, 3, 3, 2)
res = oneway_anova(y, A_num = A_num, repeat_vec = repeat_vec, method = "one", alpha = 0.05)
res$alpha_hat
res$X
y = c(12, 18, 14, 12, 13, 19, 17, 21, 24, 30) ; A_num = 4 ; repeat_vec = c(2, 3, 3, 2)
res = oneway_anova(y, A_num = A_num, repeat_vec = repeat_vec, method = "two", alpha = 0.05)
res$gamma_hat
res$X
y = c(1.7, 2.2, 3.1, 4.3, 2.5, 1.5)
## 정규방정식을 활용한 기존 방법
twoway_test = twoway_anova(y = y, A_num = 2, B_num = 3, R_num = 1, alpha = 0.05)
twoway_test$X
twoway_test$params$mu_hat
twoway_test$params$alpha_hat
twoway_test$params$beta_hat
## 방법 1 : 모형에 가정을 직접 대입하는 방식
twoway_test_one = twoway_anova(y = y, A_num = 2, B_num = 3, R_num = 1, method = "one", alpha = 0.05)
twoway_test_one$X
twoway_test_one$params$mu_hat
twoway_test_one$params$alpha_hat
twoway_test_one$params$beta_hat
## 방법 2: 변수 1개를 제거하는 방식
twoway_test_two = twoway_anova(y = y, A_num = 2, B_num = 3, R_num = 1, method = "two", alpha = 0.05)
twoway_test_two$X
twoway_test_two$params$gamma_0_hat
twoway_test_two$params$gamma_hat
twoway_test_two$params$tau_hat
y = c(2.5, 3.3, 2.6, 3.2, 1.9, 2.1,
2.6, 3.0, 2.5, 3.1, 2.0, 2.3,
2.9, 3.2, 3.1, 2.8, 2.7, 3.2,
3.0, 3.4, 2.9, 3.5, 4.2, 4.0)
## 정규방정식을 활용한 기존 방법
twoway_anova_test = twoway_anova(y, A_num = 4, B_num = 3, R_num = 2, alpha = 0.05)
twoway_anova_test$params$mu_hat
twoway_anova_test$params$alpha_hat
twoway_anova_test$params$beta_hat
twoway_anova_test$params$alpha_beta_hat
## 방법 1 : 모형에 가정을 직접 대입하는 방식
twoway_anova_test_one = twoway_anova(y, A_num = 4, B_num = 3, R_num = 2, method = "one", alpha = 0.05)
twoway_anova_test_one$params$mu_hat
twoway_anova_test_one$params$alpha_hat
twoway_anova_test_one$params$beta_hat
twoway_anova_test_one$params$alpha_beta_hat
## 방법 2: 변수 1개를 제거하는 방식
twoway_anova_test_two = twoway_anova(y = y, A_num = 4, B_num = 3, R_num = 2, method = "two", alpha = 0.05)
twoway_anova_test_two$X
twoway_anova_test_two$params$gamma_0_hat
twoway_anova_test_two$params$gamma_hat
twoway_anova_test_two$params$tau_hat
twoway_anova_test_two$params$gamma_tau_hat
group <- factor(c(rep("A", 5), rep("B", 5), rep("C", 5)))
y <- c(210, 240, 270, 270, 300, 210, 240, 240, 270, 270, 180, 210, 210, 210, 240)
aov.fit <- aov(y ~ group)
summary(aov.fit)
aov.fit$coefficients
lm.fit <- lm(y ~ group)
summary(lm.fit)
dummy.coef(aov.fit)
oneway_res = oneway_anova(y, A_num = 3, repeat_vec = c(5,5,5), alpha = 0.05)
oneway_res$alpha_hat
contrasts(group)
X <- model.matrix(~group) ; X
contrasts(group) <- contr.sum
contrasts(group)
aov.fit <- aov(y ~ group)
summary(aov.fit)
aov.fit$coefficient
dummy.coef(aov.fit)
oneway_res_one = oneway_anova(y, A_num = 3, repeat_vec = c(5,5,5), method = "one", alpha = 0.05)
oneway_res_one$alpha_hat
diet <- factor(c(1,1,2,2,2,3,3,3,4,4))
loss <- c(12, 18, 14, 12, 13, 19, 17, 21, 24, 30)
summary(aov(loss ~ diet))
fit <- lm(loss ~ diet)
anova(fit)
summary(fit)
y <- c(90.1, 90.0, 89.5, 89.8, 90.5, 90.8, 91.6, 91.4, 91.1, 91.3, 90.0, 90.6)
oneway_res = oneway_anova(y, A_num = 4, repeat_vec = c(3,3,3,3), method ="one", alpha = 0.05)
oneway_res$alpha_hat
y <- c(1.02, 0.86, 1.00, 1.22, 1.33, 1.10,
1.28, 1.72, 1.60, 1.60,
0.94, 0.86, 0.90, 1.26, 1.04)
oneway_res = oneway_anova(y, A_num = 3, repeat_vec = c(6,4,5), alpha = 0.05)
oneway_res_one = oneway_anova(y, A_num = 3, repeat_vec = c(6,4,5), method = "one", alpha = 0.05)
oneway_res_two = oneway_anova(y, A_num = 3, repeat_vec = c(6,4,5), method = "two", alpha = 0.05)
X = oneway_res$X ; X
t(X) %*% X ; t(X) %*% y
oneway_res$alpha_hat
oneway_res_one$alpha_hat
oneway_res$anova_table
oneway_res_one$anova_table
oneway_res_two$anova_table
y = c(5.2, 4.4, 4.3, 4.9,
5.0, 5.3, 5.1, 4.7,
5.5, 5.8, 4.8, 4.9,
6.9, 6.6, 6.6, 7.3,
8.3, 8.4, 8.5, 7.9)
twoway_res = twoway_anova(y, A_num = 5, B_num = 4, R_num = 1, alpha = 0.05)
A_num = 5 ; B_num = 4
mu_AB = matrix(0, nrow = B_num, ncol = A_num)
mu_hat = twoway_res$params$mu_hat
alpha_hat = twoway_res$params$alpha_hat
beta_hat = twoway_res$params$beta_hat
for (i in 1:(A_num)){
for (j in 1:B_num){
mu_AB[j,i] = beta_hat[j] + alpha_hat[i] + mu_hat
}
}
mu_AB = round(mu_AB, 2)
print(mu_AB)
twoway_res_one = twoway_anova(y, A_num = 5, B_num = 4, R_num = 1, method = "one", alpha = 0.05)
twoway_res_one$anova_table
y = c(2.5, 3.3, 2.6, 3.2, 1.9, 2.1,
2.6, 3.0, 2.5, 3.1, 2.0, 2.3,
2.9, 3.2, 3.1, 2.8, 2.7, 3.2,
3.0, 3.4, 2.9, 3.5, 4.2, 4.0)
twoway_anova_test = twoway_anova(y, A_num = 4, B_num = 3, R_num = 2, alpha = 0.05)
y <- c(61.0, 60.2, 63.3, 62.7, 61.3, 61.9,
64.1, 63.2, 66.2, 65.4, 63.2, 64.2,
65.2, 66.1, 66.6, 67.2, 66.0, 66.4)
twoway_res = twoway_anova(y = y, A_num = 3, B_num = 3, R_num = 2, method = "null", alpha = 0.05)
twoway_res$anova_table
A_num = 3 ; B_num = 3
mu_AB = matrix(0, nrow = B_num, ncol = A_num)
mu_hat = twoway_res$params$mu_hat
alpha_hat = twoway_res$params$alpha_hat
beta_hat = twoway_res$params$beta_hat
for (i in 1:(A_num)){
for (j in 1:B_num){
mu_AB[j,i] = beta_hat[j] + alpha_hat[i] + mu_hat
}
}
mu_AB = round(mu_AB, 2)
print(mu_AB)
y = c(2.5, 3.3, 2.6, 3.2, 1.9, 2.1,
2.6, 3.0, 2.5, 3.1, 2.0, 2.3,
2.9, 3.2, 3.1, 2.8, 2.7, 3.2,
3.0, 3.4, 2.9, 3.5, 4.2, 4.0)
n = length(y) ; one = c(rep(1, n))
X = cbind(one)
## A 인자 열 만들기
for (i in 1 : A_num){
temp_A_vec = c(rep(0, n))
for (a in ((i - 1) * (B_num * R_num) + 1) : (B_num * R_num * i)){
temp_A_vec[a] = 1
}
X = cbind(X, temp_A_vec)
}
y = c(2.5, 3.3, 2.6, 3.2, 1.9, 2.1,
2.6, 3.0, 2.5, 3.1, 2.0, 2.3,
2.9, 3.2, 3.1, 2.8, 2.7, 3.2,
3.0, 3.4, 2.9, 3.5, 4.2, 4.0)
A_num = 4 ; B_num = 3 ; R_num = 2 ; alpha = 0.05
n = length(y) ; one = c(rep(1, n))
X = cbind(one)
## A 인자 열 만들기
for (i in 1 : A_num){
temp_A_vec = c(rep(0, n))
for (a in ((i - 1) * (B_num * R_num) + 1) : (B_num * R_num * i)){
temp_A_vec[a] = 1
}
X = cbind(X, temp_A_vec)
}
## B 인자 열 만들기 : key point = i,j,k 구분하면서 계산하기
for (j in 1 : B_num ){
temp_B_vec = c()
for (i in 1 : A_num){
temp_b_vec = c(rep(0, (B_num * R_num)))
for (k in ((j - 1) * R_num + 1) : (j * R_num)){
temp_b_vec[k] = 1
}
temp_B_vec = c(temp_B_vec, temp_b_vec)
}
X = cbind(X, temp_B_vec)
}
colnames(X) = c("one", paste0("A_", 1:A_num), paste0("B_", 1:B_num))
X = X[,-c(1)]
X = X[,-c(1, (A_num + 1))]
X
y = c(2.5, 3.3, 2.6, 3.2, 1.9, 2.1,
2.6, 3.0, 2.5, 3.1, 2.0, 2.3,
2.9, 3.2, 3.1, 2.8, 2.7, 3.2,
3.0, 3.4, 2.9, 3.5, 4.2, 4.0)
A_num = 4 ; B_num = 3 ; R_num = 2 ; alpha = 0.05
n = length(y) ; one = c(rep(1, n))
X = cbind(one)
## A 인자 열 만들기
for (i in 1 : A_num){
temp_A_vec = c(rep(0, n))
for (a in ((i - 1) * (B_num * R_num) + 1) : (B_num * R_num * i)){
temp_A_vec[a] = 1
}
X = cbind(X, temp_A_vec)
}
## B 인자 열 만들기 : key point = i,j,k 구분하면서 계산하기
for (j in 1 : B_num ){
temp_B_vec = c()
for (i in 1 : A_num){
temp_b_vec = c(rep(0, (B_num * R_num)))
for (k in ((j - 1) * R_num + 1) : (j * R_num)){
temp_b_vec[k] = 1
}
temp_B_vec = c(temp_B_vec, temp_b_vec)
}
X = cbind(X, temp_B_vec)
}
colnames(X) = c("one", paste0("A_", 1:A_num), paste0("B_", 1:B_num))
X = X[,-c(1)]
X = X[,-c(1, (A_num + 1))]
## A X B 인자 열 만들기 : key point = 반복횟수 r만큼 점핑
for (k in 1 : (A_num * B_num) ){
temp_AB_vec = c(rep(0, n))
for (t in ((k - 1) * R_num + 1) : (k * R_num)){
temp_AB_vec[t] = 1
}
X = cbind(X, temp_AB_vec)
colnames(X)[ncol(X)] <- paste0("AB_", k)
}
X_AB = X[ , c( ((A_num - 1) * (B_num - 1)) : ((2 * A_num * B_num) - A_num - B_num) )]
X = X[ , -c( ((A_num - 1) * (B_num - 1)) : ((2 * A_num * B_num) - A_num - B_num) )]
X
X_AB
# X_AB = X_AB[ , -c(((A_num - 1)*B_num +1) : (A_num * B_num))]
# X_AB = X_AB[ , -c(seq(from = B_num, to = (B_num * (A_num - 1)), by = B_num))]
#
# X = cbind(X, X_AB)
#
# mult_reg_res = mult_reg(X, y, alpha = alpha, coeff = TRUE)
# gamma_0_hat = mult_reg_res$beta_hat[1]
# gamma_hat = mult_reg_res$beta_hat[2:(A_num)]
# tau_hat = mult_reg_res$beta_hat[(A_num + 1) : (A_num + B_num - 1)]
# gamma_tau_hat_vec = mult_reg_res$beta_hat[(A_num + B_num) : ((A_num - 1) * (B_num - 1) + (A_num + B_num) - 1)]
# gamma_tau_hat_mat = matrix(gamma_tau_hat_vec, ncol = (A_num - 1))
#
# params = list(gamma_0_hat = gamma_0_hat, gamma_hat = gamma_hat, tau_hat = tau_hat, gamma_tau_hat = gamma_tau_hat_mat)
#
# anova_table = mult_reg_res$anova_table
y = c(2.5, 3.3, 2.6, 3.2, 1.9, 2.1,
2.6, 3.0, 2.5, 3.1, 2.0, 2.3,
2.9, 3.2, 3.1, 2.8, 2.7, 3.2,
3.0, 3.4, 2.9, 3.5, 4.2, 4.0)
A_num = 4 ; B_num = 3 ; R_num = 2 ; alpha = 0.05
n = length(y) ; one = c(rep(1, n))
X = cbind(one)
## A 인자 열 만들기
for (i in 1 : A_num){
temp_A_vec = c(rep(0, n))
for (a in ((i - 1) * (B_num * R_num) + 1) : (B_num * R_num * i)){
temp_A_vec[a] = 1
}
X = cbind(X, temp_A_vec)
}
## B 인자 열 만들기 : key point = i,j,k 구분하면서 계산하기
for (j in 1 : B_num ){
temp_B_vec = c()
for (i in 1 : A_num){
temp_b_vec = c(rep(0, (B_num * R_num)))
for (k in ((j - 1) * R_num + 1) : (j * R_num)){
temp_b_vec[k] = 1
}
temp_B_vec = c(temp_B_vec, temp_b_vec)
}
X = cbind(X, temp_B_vec)
}
colnames(X) = c("one", paste0("A_", 1:A_num), paste0("B_", 1:B_num))
X = X[,-c(1)]
X = X[,-c(1, (A_num + 1))]
## A X B 인자 열 만들기 : key point = 반복횟수 r만큼 점핑
for (k in 1 : (A_num * B_num) ){
temp_AB_vec = c(rep(0, n))
for (t in ((k - 1) * R_num + 1) : (k * R_num)){
temp_AB_vec[t] = 1
}
X = cbind(X, temp_AB_vec)
colnames(X)[ncol(X)] <- paste0("AB_", k)
}
X_AB = X[ , c( ((A_num - 1) * (B_num - 1)) : ((2 * A_num * B_num) - A_num - B_num) )]
X = X[ , -c( ((A_num - 1) * (B_num - 1)) : ((2 * A_num * B_num) - A_num - B_num) )]
X_AB = X_AB[ , -c(1 : B_num)]
X_AB = X_AB[ , -c(seq(from = 1, to = (1 + (B_num - 1) * (A_num - 1)), by = B_num))]
X = cbind(X, X_AB)
mult_reg_res = mult_reg(X, y, alpha = alpha, coeff = TRUE)
gamma_0_hat = mult_reg_res$beta_hat[1]
gamma_hat = mult_reg_res$beta_hat[2:(A_num)]
tau_hat = mult_reg_res$beta_hat[(A_num + 1) : (A_num + B_num - 1)]
gamma_tau_hat_vec = mult_reg_res$beta_hat[(A_num + B_num) : ((A_num - 1) * (B_num - 1) + (A_num + B_num) - 1)]
gamma_tau_hat_mat = matrix(gamma_tau_hat_vec, ncol = (A_num - 1))
params = list(gamma_0_hat = gamma_0_hat, gamma_hat = gamma_hat, tau_hat = tau_hat, gamma_tau_hat = gamma_tau_hat_mat)
anova_table = mult_reg_res$anova_table
anova_table
y = c(2.5, 3.3, 2.6, 3.2, 1.9, 2.1,
2.6, 3.0, 2.5, 3.1, 2.0, 2.3,
2.9, 3.2, 3.1, 2.8, 2.7, 3.2,
3.0, 3.4, 2.9, 3.5, 4.2, 4.0)
A_num = 4 ; B_num = 3 ; R_num = 2 ; alpha = 0.05
n = length(y) ; one = c(rep(1, n))
X = cbind(one)
## A 인자 열 만들기
for (i in 1 : A_num){
temp_A_vec = c(rep(0, n))
for (a in ((i - 1) * (B_num * R_num) + 1) : (B_num * R_num * i)){
temp_A_vec[a] = 1
}
X = cbind(X, temp_A_vec)
}
## B 인자 열 만들기 : key point = i,j,k 구분하면서 계산하기
for (j in 1 : B_num ){
temp_B_vec = c()
for (i in 1 : A_num){
temp_b_vec = c(rep(0, (B_num * R_num)))
for (k in ((j - 1) * R_num + 1) : (j * R_num)){
temp_b_vec[k] = 1
}
temp_B_vec = c(temp_B_vec, temp_b_vec)
}
X = cbind(X, temp_B_vec)
}
colnames(X) = c("one", paste0("A_", 1:A_num), paste0("B_", 1:B_num))
X = X[,-c(1)]
X = X[,-c(1, (A_num + 1))]
## A X B 인자 열 만들기 : key point = 반복횟수 r만큼 점핑
for (k in 1 : (A_num * B_num) ){
temp_AB_vec = c(rep(0, n))
for (t in ((k - 1) * R_num + 1) : (k * R_num)){
temp_AB_vec[t] = 1
}
X = cbind(X, temp_AB_vec)
colnames(X)[ncol(X)] <- paste0("AB_", k)
}
X_AB = X[ , c( ((A_num - 1) * (B_num - 1)) : ((2 * A_num * B_num) - A_num - B_num) )]
X = X[ , -c( ((A_num - 1) * (B_num - 1)) : ((2 * A_num * B_num) - A_num - B_num) )]
X_AB = X_AB[ , -c(1 : B_num)]
X_AB = X_AB[ , -c(seq(from = 1, to = (1 + (B_num - 1) * (A_num - 1)), by = B_num))]
X = cbind(X, X_AB)
mult_reg_res = mult_reg(X, y, alpha = alpha, coeff = TRUE)
gamma_0_hat = mult_reg_res$beta_hat[1]
gamma_hat = mult_reg_res$beta_hat[2:(A_num)]
tau_hat = mult_reg_res$beta_hat[(A_num + 1) : (A_num + B_num - 1)]
gamma_tau_hat_vec = mult_reg_res$beta_hat[(A_num + B_num) : ((A_num - 1) * (B_num - 1) + (A_num + B_num) - 1)]
gamma_tau_hat_mat = matrix(gamma_tau_hat_vec, ncol = (A_num - 1))
params = list(gamma_0_hat = gamma_0_hat, gamma_hat = gamma_hat, tau_hat = tau_hat, gamma_tau_hat = gamma_tau_hat_mat)
anova_table = mult_reg_res$anova_table
anova_table[,c(2:6)] = round(anova_table[,c(2:6)], 2)
anova_table
