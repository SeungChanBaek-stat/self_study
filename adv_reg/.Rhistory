source("functions/biased_reg.R", echo = F)
X = hitters_dat %>%
dplyr::select(-Salary)
y = hitters_dat %>%
dplyr::select(Salary)
X_dummy = dummy_var_gen(X)
X_mat <- as.matrix(X_dummy)
y_mat <- as.matrix(y)
## 부분최소제곱회귀
pls_res1 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "ortho_invar")
# pls_res2 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "scale_invar")
source("functions/biased_reg.R", echo = F)
X = hitters_dat %>%
dplyr::select(-Salary)
y = hitters_dat %>%
dplyr::select(Salary)
X_dummy = dummy_var_gen(X)
X_mat <- as.matrix(X_dummy)
y_mat <- as.matrix(y)
## 부분최소제곱회귀
pls_res1 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "ortho_invar")
# pls_res2 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "scale_invar")
pls_res2 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "scale_invar")
source("functions/biased_reg.R", echo = F)
X = hitters_dat %>%
dplyr::select(-Salary)
y = hitters_dat %>%
dplyr::select(Salary)
X_dummy = dummy_var_gen(X)
X_mat <- as.matrix(X_dummy)
y_mat <- as.matrix(y)
## 부분최소제곱회귀
pls_res1 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "ortho_invar")
# pls_res2 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "scale_invar")
T_mat = pls_res1$T_mat
cor(T_mat)
source("functions/biased_reg.R", echo = F)
X = hitters_dat %>%
dplyr::select(-Salary)
y = hitters_dat %>%
dplyr::select(Salary)
X_dummy = dummy_var_gen(X)
X_mat <- as.matrix(X_dummy)
y_mat <- as.matrix(y)
## 부분최소제곱회귀
pls_res1 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "ortho_invar")
# pls_res2 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "scale_invar")
T_mat = pls_res1$T_mat
cor(T_mat)
T_mat
source("functions/biased_reg.R", echo = F)
X = hitters_dat %>%
dplyr::select(-Salary)
y = hitters_dat %>%
dplyr::select(Salary)
X_dummy = dummy_var_gen(X)
X_mat <- as.matrix(X_dummy)
y_mat <- as.matrix(y)
## 부분최소제곱회귀
pls_res1 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "ortho_invar")
source("functions/biased_reg.R", echo = F)
X = hitters_dat %>%
dplyr::select(-Salary)
y = hitters_dat %>%
dplyr::select(Salary)
X_dummy = dummy_var_gen(X)
X_mat <- as.matrix(X_dummy)
y_mat <- as.matrix(y)
## 부분최소제곱회귀
pls_res1 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "ortho_invar")
# pls_res2 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "scale_invar")
## 부분최소제곱회귀 - 방법 2 : 척도변환 불변 방법
pls_res2 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "scale_invar")
cor(pls_res1$T_mat)
source("functions/biased_reg.R", echo = F)
X = hitters_dat %>%
dplyr::select(-Salary)
y = hitters_dat %>%
dplyr::select(Salary)
X_dummy = dummy_var_gen(X)
X_mat <- as.matrix(X_dummy)
y_mat <- as.matrix(y)
## 부분최소제곱회귀 - 방법 1 : 직교변환 불변 방법
pls_res1 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "ortho_invar")
cor(pls_res1$T_mat)
X = mtcars[, -1] ; y = mtcars$mpg
X_mat = as.matrix(X) ; y_mat = as.matrix(y)
pls_mpg_res1 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "ortho_var")
X = mtcars[, -1] ; y = mtcars$mpg
X_mat = as.matrix(X) ; y_mat = as.matrix(y)
pls_mpg_res1 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "scale_var")
source("functions/biased_reg.R", echo = F)
X = hitters_dat %>%
dplyr::select(-Salary)
y = hitters_dat %>%
dplyr::select(Salary)
X_dummy = dummy_var_gen(X)
X_mat <- as.matrix(X_dummy)
y_mat <- as.matrix(y)
## 부분최소제곱회귀 - 방법 1 : 직교변환 불변 방법
pls_res1 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "ortho_invar")
cor(pls_res1$T_mat)
## 부분최소제곱회귀 - 방법 2 : 척도변환 불변 방법
pls_res2 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "scale_invar")
source("functions/biased_reg.R", echo = F)
X = hitters_dat %>%
dplyr::select(-Salary)
y = hitters_dat %>%
dplyr::select(Salary)
X_dummy = dummy_var_gen(X)
X_mat <- as.matrix(X_dummy)
y_mat <- as.matrix(y)
## 부분최소제곱회귀 - 방법 1 : 직교변환 불변 방법
pls_res1 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "ortho_invar")
## 부분최소제곱회귀 - 방법 2 : 척도변환 불변 방법
pls_res2 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "scale_invar")
source("functions/biased_reg.R", echo = F)
X = hitters_dat %>%
dplyr::select(-Salary)
y = hitters_dat %>%
dplyr::select(Salary)
X_dummy = dummy_var_gen(X)
X_mat <- as.matrix(X_dummy)
y_mat <- as.matrix(y)
## 부분최소제곱회귀 - 방법 1 : 직교변환 불변 방법
pls_res1 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "ortho_invar")
## 부분최소제곱회귀 - 방법 2 : 척도변환 불변 방법
pls_res2 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "scale_invar")
source("functions/biased_reg.R", echo = F)
X = hitters_dat %>%
dplyr::select(-Salary)
y = hitters_dat %>%
dplyr::select(Salary)
X_dummy = dummy_var_gen(X)
X_mat <- as.matrix(X_dummy)
y_mat <- as.matrix(y)
## 부분최소제곱회귀 - 방법 1 : 직교변환 불변 방법
pls_res1 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "ortho_invar")
knitr::opts_chunk$set(echo = TRUE)
source("functions/mult_reg.R", echo = F)
source("functions/reg_diagnostics.R", echo = F)
source("functions/var_selection.R", echo = F)
source("functions/anova_reg.R", echo = F)
x1 = rnorm(10, mean = 0, sd = 1)
x2 = rnorm(10, mean = 1, sd = 1)
x3 = rnorm(10, mean = 2, sd = 1)
X = cbind(x1, x2, x3)
vif_vec = vif_detect(X)
vif_vec
library(car)
library(dplyr)
fit <- lm(mpg ~ ., data = mtcars)
round(vif(fit), 2)
## vif_vec함수와의 비교 : car 패키지안에 같은 이름인 select()함수가 들어있어서 dplyr패키지를 명시적으로 실행시켜줘야한다.
X = mtcars %>%
dplyr::select(cyl:carb)
vif_vec = vif_detect(X)
round(vif_vec, 2)
library(MASS)
sc.mtcars <- data.frame(scale(mtcars))
rfit <- lm.ridge(mpg ~ ., data = mtcars, lambda = seq(0.01, 100, 0.01))
matplot(rfit$lambda, t(rfit$coef), type = "l",
xlab = expression(k), ylab = expression(bold(beta)(k)))
## ridge_reg와의 비교 : 표준화를 어떻게 하느냐에 따라 결과가 달라진다
library(dplyr)
source("functions/biased_reg.R", echo = F)
X = mtcars %>%
dplyr::select(cyl:carb)
y = mtcars %>%
dplyr::select(mpg)
lambda = seq(0.01, 100, 0.01)
ridge_coef = ridge_reg(X = X, y = y, lambda = lambda)
matplot(lambda, t(ridge_coef), type = "l",
xlab = expression(k), ylab = expression(bold(beta)(k)))
ridge_fit = lm.ridge(mpg ~ ., data = sc.mtcars, lambda = 0)
lse_fit = lm(mpg ~ . , data = sc.mtcars)
round(ridge_fit$coef, 3)
round(lse_fit$coef[-1], 3)
round(rfit$coef[,rfit$lambda == "14.91"], 3)
x <- as.matrix(mtcars[,-1])
e <- eigen(cor(x))
e$values
s.X <- scale(X) # 설명변수의 표준화
Z <- s.X %*% e$vectors # Z = XP
pcr <- lm(mtcars$mpg ~ Z)
summary(pcr)
plot(e$values, type = "l", xlab = "No. of components")
x <- as.matrix(mtcars[, -1])
y <- mtcars$mpg
cx <- sweep(x, 2, apply(x, 2, mean))
cy <- y - mean(y)
phi1 <- rep(0, 10)
for (j in 1 : length(phi1)){
phi1[j] <- crossprod(cx[,j], cy) / crossprod(cx[,j], cx[,j])
}
round(phi1, 1)
ncx <- sweep(cx, 2, phi1, "*")
t1 <- apply(ncx, 1, mean)
pls1 <- lm(cy ~ t1 - 1)
summary(pls1)
Z1 <- Z[,1] # 1st component
pcr1 <- lm(cy ~ Z1 - 1)
summary(pcr1)
varx <- apply(cx, 2, var)
vncx <- sweep(ncx, 2, varx, "*")
t1a <- apply(vncx, 1, sum)/sum(varx)
pls1a <- lm(cy ~ t1a - 1)
summary(pls1a)
cx2 <- matrix(0, 32, 10) # dim(x) = (32, 10)
for (j in 1: 10){
cx2[,j] <- lm(cx[,j] ~ t1 - 1)$res
}
cy2 <- lm(cy ~ t1 - 1)$res
phi2 <- rep(0, 10)
for (j in 1:length(phi2)){
phi2[j] <- crossprod(cx[,j], cy2)/crossprod(cx[,j], cx[,j])
}
ncx2 <- sweep(cx2, 2, phi2, "*")
t2 <- apply(ncx2, 1, mean)
cor(t1, t2)
pls2 <- lm(cy ~ t1 + t2 - 1)
summary(pls2)
pcr2 <- lm(cy ~ Z[,1:2] - 1)
summary(pcr2)
# install.packages("pls")
library(pls)
pcr.fit <- pcr(cy ~ cx, scale = T, ncomp = 1)
cbind(pcr.fit$score, Z[,1]) # 주성분 비교
pc.yhat <- predict(pcr.fit, cx)
pc.yhat1 <- predict(pcr1, as.data.frame(cx))
cbind(pc.yhat, pc.yhat1)
pls.fit <- plsr(cy ~ cx, scale = T, ncomp = 1)
yhat <- predict(pls.fit, cx)
yhat1 <- predict(pls1, as.data.frame(cx))
cbind(yhat, yhat1)
summary(pls.fit)
source("functions/mult_reg.R", echo = F)
source("functions/biased_reg.R", echo = F)
library(ISLR)
library(dplyr)
Hitters <- na.omit(Hitters)
dim(Hitters)
Hitters
hitters_dat = Hitters %>%
dplyr::select(AtBat:NewLeague)
# hitters_dat[,"Salary"]
X = hitters_dat %>%
dplyr::select(-Salary)
y = hitters_dat %>%
dplyr::select(Salary)
X_dummy = dummy_var_gen(X)
X_test = scale(X_dummy, center =TRUE, scale = TRUE)
lambda = seq(0.01, 100, 0.01)
ridge_res = ridge_reg(X = X_dummy, y = y, lambda = lambda)
ridge_coef = ridge_res
matplot(lambda, t(ridge_coef), type = "l",
xlab = expression(k), ylab = expression(bold(beta)(k)))
# 1) 기존 파라미터 백업
op <- par(no.readonly = TRUE)
# 2) 마진 조정 (아래, 왼쪽, 위, 오른쪽)
#    기본값은 c(5, 4, 4, 2) + 0.1 인데,
#    오른쪽을 넉넉히 8로 늘려줌
par(mar = c(5, 4, 4, 8) + 0.1)
# 3) matplot 그리기
matplot(lambda,
t(ridge_coef),
type = "l",
lty  = 1,
col  = 1:ncol(ridge_coef),
xlab = expression(k),
ylab = expression(bold(beta)(k)),
main = "야구선수 데이터의 능형트레이스")
# 4) xpd=NA 로 클리핑 해제하고, legend 외부로 배치
par(xpd = NA)
legend("topright",
inset  = c(-0.25, 0),            # 오른쪽 바깥쪽으로 20% 뺌
legend = rownames(ridge_coef),
col    = 1:ncol(ridge_coef),
lty    = 1,
cex    = 0.6,
bg     = "white")
# 5) 파라미터 원복
par(op)
## 표준화
X_dummy_scaled <- data.frame(scale(X_dummy))
y_scaled <- data.frame(scale(y))
X_mat = as.matrix(X_dummy_scaled) ; y_mat = as.matrix(y_scaled)
print(glue("\n"))
## 최소제곱추정법
lse_res = mult_reg(X_mat, y_mat, alpha = 0.05, coeff = TRUE)
print(t(round(lse_res$beta_hat, 2)))
## k = 0 능형회귀
ridge_k0_res = ridge_reg(X_mat, y_mat, lambda = c(0))
print(t(round(ridge_k0_res, 2)))
round(ridge_coef[,lambda == "14.91"], 2)
X_dummy_scaled <- data.frame(scale(X_dummy))
y_scaled <- data.frame(scale(y))
hitters_scaled <- cbind(X_dummy_scaled, y_scaled)
rfit_scaled <- lm.ridge(Salary ~ ., data = hitters_scaled, lambda = seq(0.01, 100, 0.01))
matplot(rfit_scaled$lambda, t(rfit_scaled$coef), type = "l",
xlab = expression(k), ylab = expression(bold(beta)(k)))
pc_res = pc_reg(X_mat, y_mat, alpha = 0.05)
R2 = pc_res$SSR / pc_res$SST ; R2
eigen_decomp = eigen(cor(X_mat))
Z = X_mat %*% eigen_decomp$vectors
pcr_res = lm(y_mat ~ Z)
summary(pcr_res)
source("functions/biased_reg.R", echo = F)
X = hitters_dat %>%
dplyr::select(-Salary)
y = hitters_dat %>%
dplyr::select(Salary)
X_dummy = dummy_var_gen(X)
X_mat <- as.matrix(X_dummy)
y_mat <- as.matrix(y)
## 부분최소제곱회귀 - 방법 1 : 직교변환 불변 방법
pls_res1 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "ortho_invar")
cor(pls_res1$T_mat)
## 부분최소제곱회귀 - 방법 2 : 척도변환 불변 방법
pls_res2 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "scale_invar")
X = mtcars[, -1] ; y = mtcars$mpg
X_mat = as.matrix(X) ; y_mat = as.matrix(y)
pls_mpg_res1 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "ortho_var")
X = mtcars[, -1] ; y = mtcars$mpg
X_mat = as.matrix(X) ; y_mat = as.matrix(y)
pls_mpg_res1 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "scale_var")
library(MASS)
X = mtcars[, -1] ; y = mtcars$mpg
X_mat = as.matrix(X) ; y_mat = as.matrix(y)
pls_mpg_res1 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "scale_var")
knitr::opts_chunk$set(echo = TRUE)
source("functions/mult_reg.R", echo = F)
source("functions/reg_diagnostics.R", echo = F)
source("functions/var_selection.R", echo = F)
source("functions/anova_reg.R", echo = F)
x1 = rnorm(10, mean = 0, sd = 1)
x2 = rnorm(10, mean = 1, sd = 1)
x3 = rnorm(10, mean = 2, sd = 1)
X = cbind(x1, x2, x3)
vif_vec = vif_detect(X)
vif_vec
library(car)
library(dplyr)
fit <- lm(mpg ~ ., data = mtcars)
round(vif(fit), 2)
## vif_vec함수와의 비교 : car 패키지안에 같은 이름인 select()함수가 들어있어서 dplyr패키지를 명시적으로 실행시켜줘야한다.
X = mtcars %>%
dplyr::select(cyl:carb)
vif_vec = vif_detect(X)
round(vif_vec, 2)
library(MASS)
sc.mtcars <- data.frame(scale(mtcars))
rfit <- lm.ridge(mpg ~ ., data = mtcars, lambda = seq(0.01, 100, 0.01))
matplot(rfit$lambda, t(rfit$coef), type = "l",
xlab = expression(k), ylab = expression(bold(beta)(k)))
## ridge_reg와의 비교 : 표준화를 어떻게 하느냐에 따라 결과가 달라진다
library(dplyr)
source("functions/biased_reg.R", echo = F)
X = mtcars %>%
dplyr::select(cyl:carb)
y = mtcars %>%
dplyr::select(mpg)
lambda = seq(0.01, 100, 0.01)
ridge_coef = ridge_reg(X = X, y = y, lambda = lambda)
matplot(lambda, t(ridge_coef), type = "l",
xlab = expression(k), ylab = expression(bold(beta)(k)))
ridge_fit = lm.ridge(mpg ~ ., data = sc.mtcars, lambda = 0)
lse_fit = lm(mpg ~ . , data = sc.mtcars)
round(ridge_fit$coef, 3)
round(lse_fit$coef[-1], 3)
round(rfit$coef[,rfit$lambda == "14.91"], 3)
x <- as.matrix(mtcars[,-1])
e <- eigen(cor(x))
e$values
s.X <- scale(X) # 설명변수의 표준화
Z <- s.X %*% e$vectors # Z = XP
pcr <- lm(mtcars$mpg ~ Z)
summary(pcr)
plot(e$values, type = "l", xlab = "No. of components")
x <- as.matrix(mtcars[, -1])
y <- mtcars$mpg
cx <- sweep(x, 2, apply(x, 2, mean))
cy <- y - mean(y)
phi1 <- rep(0, 10)
for (j in 1 : length(phi1)){
phi1[j] <- crossprod(cx[,j], cy) / crossprod(cx[,j], cx[,j])
}
round(phi1, 1)
ncx <- sweep(cx, 2, phi1, "*")
t1 <- apply(ncx, 1, mean)
pls1 <- lm(cy ~ t1 - 1)
summary(pls1)
Z1 <- Z[,1] # 1st component
pcr1 <- lm(cy ~ Z1 - 1)
summary(pcr1)
varx <- apply(cx, 2, var)
vncx <- sweep(ncx, 2, varx, "*")
t1a <- apply(vncx, 1, sum)/sum(varx)
pls1a <- lm(cy ~ t1a - 1)
summary(pls1a)
cx2 <- matrix(0, 32, 10) # dim(x) = (32, 10)
for (j in 1: 10){
cx2[,j] <- lm(cx[,j] ~ t1 - 1)$res
}
cy2 <- lm(cy ~ t1 - 1)$res
phi2 <- rep(0, 10)
for (j in 1:length(phi2)){
phi2[j] <- crossprod(cx[,j], cy2)/crossprod(cx[,j], cx[,j])
}
ncx2 <- sweep(cx2, 2, phi2, "*")
t2 <- apply(ncx2, 1, mean)
cor(t1, t2)
pls2 <- lm(cy ~ t1 + t2 - 1)
summary(pls2)
pcr2 <- lm(cy ~ Z[,1:2] - 1)
summary(pcr2)
# install.packages("pls")
library(pls)
pcr.fit <- pcr(cy ~ cx, scale = T, ncomp = 1)
cbind(pcr.fit$score, Z[,1]) # 주성분 비교
pc.yhat <- predict(pcr.fit, cx)
pc.yhat1 <- predict(pcr1, as.data.frame(cx))
cbind(pc.yhat, pc.yhat1)
pls.fit <- plsr(cy ~ cx, scale = T, ncomp = 1)
yhat <- predict(pls.fit, cx)
yhat1 <- predict(pls1, as.data.frame(cx))
cbind(yhat, yhat1)
summary(pls.fit)
source("functions/mult_reg.R", echo = F)
source("functions/biased_reg.R", echo = F)
library(ISLR)
library(dplyr)
Hitters <- na.omit(Hitters)
dim(Hitters)
Hitters
hitters_dat = Hitters %>%
dplyr::select(AtBat:NewLeague)
# hitters_dat[,"Salary"]
X = hitters_dat %>%
dplyr::select(-Salary)
y = hitters_dat %>%
dplyr::select(Salary)
X_dummy = dummy_var_gen(X)
X_test = scale(X_dummy, center =TRUE, scale = TRUE)
lambda = seq(0.01, 100, 0.01)
ridge_res = ridge_reg(X = X_dummy, y = y, lambda = lambda)
ridge_coef = ridge_res
matplot(lambda, t(ridge_coef), type = "l",
xlab = expression(k), ylab = expression(bold(beta)(k)))
# 1) 기존 파라미터 백업
op <- par(no.readonly = TRUE)
# 2) 마진 조정 (아래, 왼쪽, 위, 오른쪽)
#    기본값은 c(5, 4, 4, 2) + 0.1 인데,
#    오른쪽을 넉넉히 8로 늘려줌
par(mar = c(5, 4, 4, 8) + 0.1)
# 3) matplot 그리기
matplot(lambda,
t(ridge_coef),
type = "l",
lty  = 1,
col  = 1:ncol(ridge_coef),
xlab = expression(k),
ylab = expression(bold(beta)(k)),
main = "야구선수 데이터의 능형트레이스")
# 4) xpd=NA 로 클리핑 해제하고, legend 외부로 배치
par(xpd = NA)
legend("topright",
inset  = c(-0.25, 0),            # 오른쪽 바깥쪽으로 20% 뺌
legend = rownames(ridge_coef),
col    = 1:ncol(ridge_coef),
lty    = 1,
cex    = 0.6,
bg     = "white")
# 5) 파라미터 원복
par(op)
## 표준화
X_dummy_scaled <- data.frame(scale(X_dummy))
y_scaled <- data.frame(scale(y))
X_mat = as.matrix(X_dummy_scaled) ; y_mat = as.matrix(y_scaled)
print(glue("\n"))
## 최소제곱추정법
lse_res = mult_reg(X_mat, y_mat, alpha = 0.05, coeff = TRUE)
print(t(round(lse_res$beta_hat, 2)))
## k = 0 능형회귀
ridge_k0_res = ridge_reg(X_mat, y_mat, lambda = c(0))
print(t(round(ridge_k0_res, 2)))
round(ridge_coef[,lambda == "14.91"], 2)
X_dummy_scaled <- data.frame(scale(X_dummy))
y_scaled <- data.frame(scale(y))
hitters_scaled <- cbind(X_dummy_scaled, y_scaled)
rfit_scaled <- lm.ridge(Salary ~ ., data = hitters_scaled, lambda = seq(0.01, 100, 0.01))
matplot(rfit_scaled$lambda, t(rfit_scaled$coef), type = "l",
xlab = expression(k), ylab = expression(bold(beta)(k)))
pc_res = pc_reg(X_mat, y_mat, alpha = 0.05)
R2 = pc_res$SSR / pc_res$SST ; R2
eigen_decomp = eigen(cor(X_mat))
Z = X_mat %*% eigen_decomp$vectors
pcr_res = lm(y_mat ~ Z)
summary(pcr_res)
source("functions/biased_reg.R", echo = F)
X = hitters_dat %>%
dplyr::select(-Salary)
y = hitters_dat %>%
dplyr::select(Salary)
X_dummy = dummy_var_gen(X)
X_mat <- as.matrix(X_dummy)
y_mat <- as.matrix(y)
## 부분최소제곱회귀 - 방법 1 : 직교변환 불변 방법
pls_res1 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "ortho_invar")
cor(pls_res1$T_mat)
## 부분최소제곱회귀 - 방법 2 : 척도변환 불변 방법
pls_res2 = pls_reg(X_mat, y_mat, alpha = 0.05, method = "scale_invar")
